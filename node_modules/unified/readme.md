# [![unified][logo]][site]

[![Build][build-badge]][build]
[![Coverage][coverage-badge]][coverage]
[![Downloads][downloads-badge]][downloads]
[![Size][size-badge]][size]
[![Sponsors][sponsors-badge]][collective]
[![Backers][backers-badge]][collective]
[![Chat][chat-badge]][chat]

<<<<<<< HEAD
**unified** is an interface for processing text using syntax trees.
It‚Äôs what powers [**remark**][remark] (Markdown), [**retext**][retext] (natural
language), and [**rehype**][rehype] (HTML), and allows for processing between
formats.

## Intro

**unified** enables new exciting projects like [Gatsby][] to pull in Markdown,
[MDX][] to embed [JSX][], and [Prettier][] to format it.
It‚Äôs used in about 700k projects on GitHub and has about 35m downloads each
month on npm: you‚Äôre probably using it.
Some notable users are [Node.js][], [Vercel][], [Netlify][], [GitHub][],
[Mozilla][], [WordPress][], [Adobe][], [Facebook][], [Google][], and many more.

*   To read about what we are up to, follow us [Twitter][]
*   For a less technical and more practical introduction to unified, visit
    [`unifiedjs.com`][site] and peruse its [Learn][] section
*   Browse [awesome unified][awesome] to find out more about the ecosystem
*   Questions?
    Get help on [Discussions][chat]!
*   Check out [Contribute][] below to find out how to help out, or become a
    backer or sponsor on [OpenCollective][collective]

## Sponsors

Support this effort and give back by sponsoring on [OpenCollective][collective]!

<!--lint ignore no-html-->

=======
**unified** lets you inspect and transform content with plugins.

## Contents

* [What is this?](#what-is-this)
* [When should I use this?](#when-should-i-use-this)
* [Install](#install)
* [Use](#use)
* [Overview](#overview)
* [API](#api)
  * [`processor()`](#processor)
  * [`processor.compiler`](#processorcompiler)
  * [`processor.data([key[, value]])`](#processordatakey-value)
  * [`processor.freeze()`](#processorfreeze)
  * [`processor.parse(file)`](#processorparsefile)
  * [`processor.parser`](#processorparser)
  * [`processor.process(file[, done])`](#processorprocessfile-done)
  * [`processor.processSync(file)`](#processorprocesssyncfile)
  * [`processor.run(tree[, file][, done])`](#processorruntree-file-done)
  * [`processor.runSync(tree[, file])`](#processorrunsynctree-file)
  * [`processor.stringify(tree[, file])`](#processorstringifytree-file)
  * [`processor.use(plugin[, options])`](#processoruseplugin-options)
  * [`CompileResultMap`](#compileresultmap)
  * [`CompileResults`](#compileresults)
  * [`Compiler`](#compiler)
  * [`Data`](#data)
  * [`Parser`](#parser)
  * [`Pluggable`](#pluggable)
  * [`PluggableList`](#pluggablelist)
  * [`Plugin`](#plugin)
  * [`PluginTuple`](#plugintuple)
  * [`Preset`](#preset)
  * [`ProcessCallback`](#processcallback)
  * [`Processor`](#processor-1)
  * [`RunCallback`](#runcallback)
  * [`Settings`](#settings)
  * [`TransformCallback`](#transformcallback)
  * [`Transformer`](#transformer)
* [Types](#types)
* [Compatibility](#compatibility)
* [Contribute](#contribute)
* [Sponsor](#sponsor)
* [Acknowledgments](#acknowledgments)
* [License](#license)

## What is this?

unified is two things:

* **unified** is a collective of 500+ free and open source packages that work
  with content as structured data (ASTs)
* `unified` (this project) is the core package, used in 1.3m+ projects on GH,
  to process content with plugins

Several ecosystems are built on unified around different kinds of content.
Notably, [remark][] (markdown), [rehype][] (HTML), and [retext][] (natural
language).
These ecosystems can be connected together.

* for more about us, see [`unifiedjs.com`][site]
* for updates, see [@unifiedjs][twitter] on Twitter
* for questions, see [support][]
* to help, see [contribute][] and [sponsor][] below

## When should I use this?

In some cases, you are already using unified.
For example, it‚Äôs used in MDX, Gatsby, Docusaurus, etc.
In those cases, you don‚Äôt need to add `unified` yourself but you can include
plugins into those projects.

But the real fun (for some) is to get your hands dirty and work with syntax
trees and build with it yourself.
You can create those projects, or things like Prettier, or your own site
generator.
You can connect utilities together and make your own plugins that check for
problems and transform from one thing to another.

When you are dealing with one type of content (such as markdown), you can use
the main package of that ecosystem instead (so `remark`).
When you are dealing with different kinds of content (such as markdown and
HTML), it‚Äôs recommended to use `unified` itself, and pick and choose the plugins
you need.

## Install

This package is [ESM only][esm].
In Node.js (version 16+), install with [npm][]:

```sh
npm install unified
```

In Deno with [`esm.sh`][esmsh]:

```js
import {unified} from 'https://esm.sh/unified@11'
```

In browsers with [`esm.sh`][esmsh]:

```html
<script type="module">
  import {unified} from 'https://esm.sh/unified@11?bundle'
</script>
```

## Use

```js
import rehypeDocument from 'rehype-document'
import rehypeFormat from 'rehype-format'
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import {unified} from 'unified'
import {reporter} from 'vfile-reporter'

const file = await unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeDocument, {title: 'üëãüåç'})
  .use(rehypeFormat)
  .use(rehypeStringify)
  .process('# Hello world!')

console.error(reporter(file))
console.log(String(file))
```

Yields:

```txt
no issues found
```

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>üëãüåç</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
```

<!-- Old name: -->

<a name="description"></a>

## Overview

`unified` is an interface for processing content with syntax trees.
Syntax trees are a representation of content understandable to programs.
Those programs, called *[plugins][api-plugin]*, take these trees and inspect and
modify them.
To get to the syntax tree from text, there is a *[parser][api-parser]*.
To get from that back to text, there is a *[compiler][api-compiler]*.
This is the *[process][api-process]* of a *processor*.

```ascii
| ........................ process ........................... |
| .......... parse ... | ... run ... | ... stringify ..........|

          +--------+                     +----------+
Input ->- | Parser | ->- Syntax Tree ->- | Compiler | ->- Output
          +--------+          |          +----------+
                              X
                              |
                       +--------------+
                       | Transformers |
                       +--------------+
```

###### Processors

Processors process content.
On its own, `unified` (the root processor) doesn‚Äôt work.
It needs to be configured with plugins to work.
For example:

```js
const processor = unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeDocument, {title: 'üëãüåç'})
  .use(rehypeFormat)
  .use(rehypeStringify)
```

That processor can do different things.
It can:

* ‚Ä¶parse markdown (`parse`)
* ‚Ä¶turn parsed markdown into HTML and format the HTML (`run`)
* ‚Ä¶compile HTML (`stringify`)
* ‚Ä¶do all of the above (`process`)

Every processor implements another processor.
To create a processor, call another processor.
The new processor is configured to work the same as its ancestor.
But when the descendant processor is configured in the future it does not affect
the ancestral processor.

When processors are exposed from a module (for example, `unified` itself) they
should not be configured directly, as that would change their behavior for all
module users.
Those processors are *[frozen][api-freeze]* and they should be called to create
a new processor before they are used.

###### File

When processing a document, metadata is gathered about that document.
[`vfile`][vfile] is the file format that stores data, metadata, and messages
about files for unified and plugins.

There are several [utilities][vfile-utilities] for working with these files.

###### Syntax tree

The syntax trees used in unified are [unist][] nodes.
A tree represents a whole document and each [node][] is a plain JavaScript
object with a `type` field.
The semantics of nodes and the format of syntax trees is defined by other
projects:

* [esast][] ‚Äî JavaScript
* [hast][] ‚Äî HTML
* [mdast][] ‚Äî markdown
* [nlcst][] ‚Äî natural language
* [xast][] ‚Äî XML

There are many utilities for working with trees listed in each aforementioned
project and maintained in the [`syntax-tree`][syntax-tree] organization.
These utilities are a level lower than unified itself and are building blocks
that can be used to make plugins.

<!-- Old name: -->

<a name="list-of-processors"></a>

###### Ecosystems

Around each syntax tree is an ecosystem that focusses on that particular kind
of content.
At their core, they parse text to a tree and compile that tree back to text.
They also provide plugins that work with the syntax tree, without requiring
that the end user has knowledge about that tree.

* [rehype][] (hast) ‚Äî HTML
* [remark][] (mdast) ‚Äî markdown
* [retext][] (nlcst) ‚Äî natural language

<a name="list-of-plugins"></a>

###### Plugins

Each aforementioned ecosystem comes with a large set of plugins that you can
pick and choose from to do all kinds of things.

* [List of remark plugins][remark-plugins] ¬∑
  [`remarkjs/awesome-remark`][awesome-remark] ¬∑
  [`remark-plugin` topic][topic-remark-plugin]
* [List of rehype plugins][rehype-plugins] ¬∑
  [`rehypejs/awesome-rehype`][awesome-rehype] ¬∑
  [`rehype-plugin` topic][topic-rehype-plugin]
* [List of retext plugins][retext-plugins] ¬∑
  [`retextjs/awesome-retext`][awesome-retext] ¬∑
  [`retext-plugin` topic][topic-retext-plugin]

There are also a few plugins that work in any ecosystem:

* [`unified-diff`](https://github.com/unifiedjs/unified-diff)
  ‚Äî ignore unrelated messages in GitHub Actions and Travis
* [`unified-infer-git-meta`](https://github.com/unifiedjs/unified-infer-git-meta)
  ‚Äî infer metadata of a document from Git
* [`unified-message-control`](https://github.com/unifiedjs/unified-message-control)
  ‚Äî enable, disable, and ignore messages from content

###### Configuration

Processors are configured with [plugins][api-plugin] or with the
[`data`][api-data] method.
Most plugins also accept configuration through options.
See each plugin‚Äôs readme for more info.

###### Integrations

unified can integrate with the file system through
[`unified-engine`][unified-engine].
CLI apps can be created with [`unified-args`][unified-args], Gulp plugins with
[`unified-engine-gulp`][unified-engine-gulp], and language servers with
[`unified-language-server`][unified-language-server].
A streaming interface can be created with [`unified-stream`][unified-stream].

###### Programming interface

The [API][] provided by `unified` allows multiple files to be processed and
gives access to metadata (such as lint messages):

```js
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkPresetLintMarkdownStyleGuide from 'remark-preset-lint-markdown-style-guide'
import remarkRehype from 'remark-rehype'
import remarkRetext from 'remark-retext'
import retextEnglish from 'retext-english'
import retextEquality from 'retext-equality'
import {unified} from 'unified'
import {reporter} from 'vfile-reporter'

const file = await unified()
  .use(remarkParse)
  .use(remarkPresetLintMarkdownStyleGuide)
  .use(remarkRetext, unified().use(retextEnglish).use(retextEquality))
  .use(remarkRehype)
  .use(rehypeStringify)
  .process('*Emphasis* and _stress_, you guys!')

console.error(reporter(file))
console.log(String(file))
```

Yields:

```txt
1:16-1:24 warning Emphasis should use `*` as a marker                                 emphasis-marker remark-lint
1:30-1:34 warning `guys` may be insensitive, use `people`, `persons`, `folks` instead gals-man        retext-equality

‚ö† 2 warnings
```

```html
<p><em>Emphasis</em> and <em>stress</em>, you guys!</p>
```

<!-- Old name: -->

<a name="processing-between-syntaxes"></a>

###### Transforming between ecosystems

Ecosystems can be combined in two modes.

**Bridge** mode transforms the tree from one format (*origin*) to another
(*destination*).
A different processor runs on the destination tree.
Afterwards, the original processor continues with the origin tree.

**Mutate** mode also transforms the syntax tree from one format to another.
But the original processor continues transforming the destination tree.

In the previous example (‚ÄúProgramming interface‚Äù), `remark-retext` is used in
bridge mode: the origin syntax tree is kept after retext is done; whereas
`remark-rehype` is used in mutate mode: it sets a new syntax tree and discards
the origin tree.

The following plugins lets you combine ecosystems:

* [`remark-retext`][remark-retext] ‚Äî turn markdown into natural language
* [`remark-rehype`][remark-rehype] ‚Äî turn markdown into HTML
* [`rehype-retext`][rehype-retext] ‚Äî turn HTML into natural language
* [`rehype-remark`][rehype-remark] ‚Äî turn HTML into markdown

## API

This package exports the identifier `unified` (the root `processor`).
There is no default export.

### `processor()`

Create a new processor.

###### Returns

New *[unfrozen][api-freeze]* processor ([`processor`][api-processor]).

This processor is configured to work the same as its ancestor.
When the descendant processor is configured in the future it does not affect
the ancestral processor.

###### Example

This example shows how a new processor can be created (from `remark`) and linked
to **stdin**(4) and **stdout**(4).

```js
import process from 'node:process'
import concatStream from 'concat-stream'
import {remark} from 'remark'

process.stdin.pipe(
  concatStream(function (buf) {
    process.stdout.write(String(remark().processSync(buf)))
  })
)
```

### `processor.compiler`

Compiler to use ([`Compiler`][api-compiler], optional).

### `processor.data([key[, value]])`

Configure the processor with info available to all plugins.
Information is stored in an object.

Typically, options can be given to a specific plugin, but sometimes it makes
sense to have information shared with several plugins.
For example, a list of HTML elements that are self-closing, which is needed
during all [phases][overview].

> üëâ **Note**: setting information cannot occur on *[frozen][api-freeze]*
> processors.
> Call the processor first to create a new unfrozen processor.

> üëâ **Note**: to register custom data in TypeScript, augment the
> [`Data`][api-data] interface.

###### Signatures

* `processor = processor.data(key, value)`
* `processor = processor.data(dataset)`
* `value = processor.data(key)`
* `dataset = processor.data()`

###### Parameters

* `key` ([`keyof Data`][api-data], optional) ‚Äî field to get
* `value` ([`Data[key]`][api-data]) ‚Äî value to set
* `values` ([`Data`][api-data]) ‚Äî values to set

###### Returns

The current processor when setting ([`processor`][api-processor]), the value at
`key` when getting ([`Data[key]`][api-data]), or the entire dataset when
getting without key ([`Data`][api-data]).

###### Example

This example show how to get and set info:

```js
import {unified} from 'unified'

const processor = unified().data('alpha', 'bravo')

processor.data('alpha') // => 'bravo'

processor.data() // => {alpha: 'bravo'}

processor.data({charlie: 'delta'})

processor.data() // => {charlie: 'delta'}
```

### `processor.freeze()`

Freeze a processor.

Frozen processors are meant to be extended and not to be configured directly.

When a processor is frozen it cannot be unfrozen.
New processors working the same way can be created by calling the processor.

It‚Äôs possible to freeze processors explicitly by calling `.freeze()`.
Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
`.stringify()`, `.process()`, or `.processSync()` are called.

###### Returns

The current processor ([`processor`][api-processor]).

###### Example

This example, `index.js`, shows how `rehype` prevents extensions to itself:

```js
import rehypeParse from 'rehype-parse'
import rehypeStringify from 'rehype-stringify'
import {unified} from 'unified'

export const rehype = unified().use(rehypeParse).use(rehypeStringify).freeze()
```

That processor can be used and configured like so:

```js
import {rehype} from 'rehype'
import rehypeFormat from 'rehype-format'
// ‚Ä¶

rehype()
  .use(rehypeFormat)
  // ‚Ä¶
```

A similar looking example is broken as operates on the frozen interface.
If this behavior was allowed it would result in unexpected behavior so an error
is thrown.
**This is not valid**:

```js
import {rehype} from 'rehype'
import rehypeFormat from 'rehype-format'
// ‚Ä¶

rehype
  .use(rehypeFormat)
  // ‚Ä¶
```

Yields:

```txt
~/node_modules/unified/index.js:426
    throw new Error(
    ^

Error: Cannot call `use` on a frozen processor.
Create a new processor first, by calling it: use `processor()` instead of `processor`.
    at assertUnfrozen (~/node_modules/unified/index.js:426:11)
    at Function.use (~/node_modules/unified/index.js:165:5)
    ‚Ä¶
```

### `processor.parse(file)`

Parse text to a syntax tree.

> üëâ **Note**: `parse` freezes the processor if not already
> *[frozen][api-freeze]*.

> üëâ **Note**: `parse` performs the [parse phase][overview], not the run phase
> or other phases.

###### Parameters

* `file` ([`Compatible`][vfile-compatible]) ‚Äî file to parse; typically
  `string` or [`VFile`][vfile]; any value accepted as `x` in `new VFile(x)`

###### Returns

Syntax tree representing `file` ([`Node`][node]).

###### Example

This example shows how `parse` can be used to create a tree from a file.

```js
import remarkParse from 'remark-parse'
import {unified} from 'unified'

const tree = unified().use(remarkParse).parse('# Hello world!')

console.log(tree)
```

Yields:

```js
{
  type: 'root',
  children: [
    {type: 'heading', depth: 1, children: [Array], position: [Object]}
  ],
  position: {
    start: {line: 1, column: 1, offset: 0},
    end: {line: 1, column: 15, offset: 14}
  }
}
```

### `processor.parser`

Parser to use ([`Parser`][api-parser], optional).

### `processor.process(file[, done])`

Process the given file as configured on the processor.

> üëâ **Note**: `process` freezes the processor if not already
> *[frozen][api-freeze]*.

> üëâ **Note**: `process` performs the [parse, run, and stringify
> phases][overview].

###### Signatures

* `processor.process(file, done)`
* `Promise<VFile> = processor.process(file?)`

###### Parameters

* `file` ([`Compatible`][vfile-compatible], optional) ‚Äî file; typically
  `string` or [`VFile`][vfile]; any value accepted as `x` in `new VFile(x)`
* `done` ([`ProcessCallback`][api-process-callback], optional) ‚Äî callback

###### Returns

Nothing if `done` is given (`undefined`).
Otherwise a promise, rejected with a fatal error or resolved with the
processed file ([`Promise<VFile>`][vfile]).

The parsed, transformed, and compiled value is available at `file.value` (see
note).

> üëâ **Note**: unified typically compiles by serializing: most
> compilers return `string` (or `Uint8Array`).
> Some compilers, such as the one configured with
> [`rehype-react`][rehype-react], return other values (in this case, a React
> tree).
> If you‚Äôre using a compiler that doesn‚Äôt serialize, expect different result
> values.
>
> To register custom results in TypeScript, add them to
> [`CompileResultMap`][api-compile-result-map].

###### Example

This example shows how `process` can be used to process a file:

```js
import rehypeDocument from 'rehype-document'
import rehypeFormat from 'rehype-format'
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import {unified} from 'unified'

const file = await unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeDocument, {title: 'üëãüåç'})
  .use(rehypeFormat)
  .use(rehypeStringify)
  .process('# Hello world!')

console.log(String(file))
```

Yields:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>üëãüåç</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
```

### `processor.processSync(file)`

Process the given file as configured on the processor.

An error is thrown if asynchronous transforms are configured.

> üëâ **Note**: `processSync` freezes the processor if not already
> *[frozen][api-freeze]*.

> üëâ **Note**: `processSync` performs the [parse, run, and stringify
> phases][overview].

###### Parameters

* `file` ([`Compatible`][vfile-compatible], optional) ‚Äî file; typically
  `string` or [`VFile`][vfile]; any value accepted as `x` in `new VFile(x)`

###### Returns

The processed file ([`VFile`][vfile]).

The parsed, transformed, and compiled value is available at `file.value` (see
note).

> üëâ **Note**: unified typically compiles by serializing: most
> compilers return `string` (or `Uint8Array`).
> Some compilers, such as the one configured with
> [`rehype-react`][rehype-react], return other values (in this case, a React
> tree).
> If you‚Äôre using a compiler that doesn‚Äôt serialize, expect different result
> values.
>
> To register custom results in TypeScript, add them to
> [`CompileResultMap`][api-compile-result-map].

###### Example

This example shows how `processSync` can be used to process a file, if all
transformers are synchronous.

```js
import rehypeDocument from 'rehype-document'
import rehypeFormat from 'rehype-format'
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import {unified} from 'unified'

const processor = unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeDocument, {title: 'üëãüåç'})
  .use(rehypeFormat)
  .use(rehypeStringify)

console.log(String(processor.processSync('# Hello world!')))
```

Yields:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>üëãüåç</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
```

### `processor.run(tree[, file][, done])`

Run *[transformers][api-transformer]* on a syntax tree.

> üëâ **Note**: `run` freezes the processor if not already
> *[frozen][api-freeze]*.

> üëâ **Note**: `run` performs the [run phase][overview], not other phases.

###### Signatures

* `processor.run(tree, done)`
* `processor.run(tree, file, done)`
* `Promise<Node> = processor.run(tree, file?)`

###### Parameters

* `tree` ([`Node`][node]) ‚Äî tree to transform and inspect
* `file` ([`Compatible`][vfile-compatible], optional) ‚Äî file associated
  with `node`; any value accepted as `x` in `new VFile(x)`
* `done` ([`RunCallback`][api-run-callback], optional) ‚Äî callback

###### Returns

Nothing if `done` is given (`undefined`).
Otherwise, a promise rejected with a fatal error or resolved with the
transformed tree ([`Promise<Node>`][node]).

###### Example

This example shows how `run` can be used to transform a tree:

```js
import remarkReferenceLinks from 'remark-reference-links'
import {unified} from 'unified'
import {u} from 'unist-builder'

const tree = u('root', [
  u('paragraph', [
    u('link', {href: 'https://example.com'}, [u('text', 'Example Domain')])
  ])
])

const changedTree = await unified().use(remarkReferenceLinks).run(tree)

console.log(changedTree)
```

Yields:

```js
{
  type: 'root',
  children: [
    {type: 'paragraph', children: [Array]},
    {type: 'definition', identifier: '1', title: '', url: undefined}
  ]
}
```

### `processor.runSync(tree[, file])`

Run *[transformers][api-transformer]* on a syntax tree.

An error is thrown if asynchronous transforms are configured.

> üëâ **Note**: `runSync` freezes the processor if not already
> *[frozen][api-freeze]*.

> üëâ **Note**: `runSync` performs the [run phase][overview], not other phases.

###### Parameters

* `tree` ([`Node`][node]) ‚Äî tree to transform and inspect
* `file` ([`Compatible`][vfile-compatible], optional) ‚Äî file associated
  with `node`; any value accepted as `x` in `new VFile(x)`

###### Returns

Transformed tree ([`Node`][node]).

### `processor.stringify(tree[, file])`

Compile a syntax tree.

> üëâ **Note**: `stringify` freezes the processor if not already
> *[frozen][api-freeze]*.

> üëâ **Note**: `stringify` performs the [stringify phase][overview], not the run
> phase or other phases.

###### Parameters

* `tree` ([`Node`][node]) ‚Äî tree to compile
* `file` ([`Compatible`][vfile-compatible], optional) ‚Äî file associated
  with `node`; any value accepted as `x` in `new VFile(x)`

###### Returns

Textual representation of the tree (`Uint8Array` or `string`, see note).

> üëâ **Note**: unified typically compiles by serializing: most compilers
> return `string` (or `Uint8Array`).
> Some compilers, such as the one configured with
> [`rehype-react`][rehype-react], return other values (in this case, a
> React tree).
> If you‚Äôre using a compiler that doesn‚Äôt serialize, expect different
> result values.
>
> To register custom results in TypeScript, add them to
> [`CompileResultMap`][api-compile-result-map].

###### Example

This example shows how `stringify` can be used to serialize a syntax tree:

```js
import {h} from 'hastscript'
import rehypeStringify from 'rehype-stringify'
import {unified} from 'unified'

const tree = h('h1', 'Hello world!')

const document = unified().use(rehypeStringify).stringify(tree)

console.log(document)
```

Yields:

```html
<h1>Hello world!</h1>
```

### `processor.use(plugin[, options])`

Configure the processor to use a plugin, a list of usable values, or a preset.

If the processor is already using a plugin, the previous plugin configuration
is changed based on the options that are passed in.
In other words, the plugin is not added a second time.

> üëâ **Note**: `use` cannot be called on [*frozen*][api-freeze] processors.
> Call the processor first to create a new unfrozen processor.

###### Signatures

* `processor.use(preset?)`
* `processor.use(list)`
* `processor.use(plugin[, ...parameters])`

###### Parameters

* `preset` ([`Preset`][api-preset]) ‚Äî plugins and settings
* `list` ([`PluggableList`][api-pluggable-list]) ‚Äî list of usable things
* `plugin` ([`Plugin`][api-plugin]) ‚Äî plugin
* `parameters` (`Array<unknown>`) ‚Äî configuration for `plugin`, typically a
  single options object

###### Returns

Current processor ([`processor`][api-processor]).

###### Example

There are many ways to pass plugins to `.use()`.
This example gives an overview:

```js
import {unified} from 'unified'

unified()
  // Plugin with options:
  .use(pluginA, {x: true, y: true})
  // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
  .use(pluginA, {y: false, z: true})
  // Plugins:
  .use([pluginB, pluginC])
  // Two plugins, the second with options:
  .use([pluginD, [pluginE, {}]])
  // Preset with plugins and settings:
  .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
  // Settings only:
  .use({settings: {position: false}})
```

### `CompileResultMap`

Interface of known results from compilers (TypeScript type).

Normally, compilers result in text ([`Value`][vfile-value] of `vfile`).
When you compile to something else, such as a React node (as in,
`rehype-react`), you can augment this interface to include that type.

```ts
import type {ReactNode} from 'somewhere'

declare module 'unified' {
  interface CompileResultMap {
    // Register a new result (value is used, key should match it).
    ReactNode: ReactNode
  }
}

export {} // You may not need this, but it makes sure the file is a module.
```

Use [`CompileResults`][api-compile-results] to access the values.

###### Type

```ts
interface CompileResultMap {
  // Note: if `Value` from `VFile` is changed, this should too.
  Uint8Array: Uint8Array
  string: string
}
```

### `CompileResults`

Acceptable results from compilers (TypeScript type).

To register custom results, add them to
[`CompileResultMap`][api-compile-result-map].

###### Type

```ts
type CompileResults = CompileResultMap[keyof CompileResultMap]
```

### `Compiler`

A **compiler** handles the compiling of a syntax tree to something else
(in most cases, text) (TypeScript type).

It is used in the stringify phase and called with a [`Node`][node]
and [`VFile`][vfile] representation of the document to compile.
It should return the textual representation of the given tree (typically
`string`).

> üëâ **Note**: unified typically compiles by serializing: most compilers
> return `string` (or `Uint8Array`).
> Some compilers, such as the one configured with
> [`rehype-react`][rehype-react], return other values (in this case, a
> React tree).
> If you‚Äôre using a compiler that doesn‚Äôt serialize, expect different
> result values.
>
> To register custom results in TypeScript, add them to
> [`CompileResultMap`][api-compile-result-map].

###### Type

```ts
type Compiler<
  Tree extends Node = Node,
  Result extends CompileResults = CompileResults
> = (tree: Tree, file: VFile) => Result
```

### `Data`

Interface of known data that can be supported by all plugins (TypeScript type).

Typically, options can be given to a specific plugin, but sometimes it makes
sense to have information shared with several plugins.
For example, a list of HTML elements that are self-closing, which is needed
during all phases.

To type this, do something like:

```ts
declare module 'unified' {
  interface Data {
    htmlVoidElements?: Array<string> | undefined
  }
}

export {} // You may not need this, but it makes sure the file is a module.
```

###### Type

```ts
interface Data {
  settings?: Settings | undefined
}
```

See [`Settings`][api-settings] for more info.

### `Parser`

A **parser** handles the parsing of text to a syntax tree (TypeScript type).

It is used in the parse phase and is called with a `string` and
[`VFile`][vfile] of the document to parse.
It must return the syntax tree representation of the given file
([`Node`][node]).

###### Type

```ts
type Parser<Tree extends Node = Node> = (document: string, file: VFile) => Tree
```

### `Pluggable`

Union of the different ways to add plugins and settings (TypeScript type).

###### Type

```ts
type Pluggable =
  | Plugin<Array<any>, any, any>
  | PluginTuple<Array<any>, any, any>
  | Preset
```

See [`Plugin`][api-plugin], [`PluginTuple`][api-plugin-tuple],
and [`Preset`][api-preset] for more info.

### `PluggableList`

List of plugins and presets (TypeScript type).

###### Type

```ts
type PluggableList = Array<Pluggable>
```

See [`Pluggable`][api-pluggable] for more info.

### `Plugin`

Single plugin (TypeScript type).

Plugins configure the processors they are applied on in the following ways:

* they change the processor, such as the parser, the compiler, or by
  configuring data
* they specify how to handle trees and files

In practice, they are functions that can receive options and configure the
processor (`this`).

> üëâ **Note**: plugins are called when the processor is *frozen*, not when they
> are applied.

###### Type

```ts
type Plugin<
  PluginParameters extends unknown[] = [],
  Input extends Node | string | undefined = Node,
  Output = Input
> = (
  this: Processor,
  ...parameters: PluginParameters
) => Input extends string // Parser.
  ? Output extends Node | undefined
    ? undefined | void
    : never
  : Output extends CompileResults // Compiler.
  ? Input extends Node | undefined
    ? undefined | void
    : never
  : // Inspect/transform.
      | Transformer<
          Input extends Node ? Input : Node,
          Output extends Node ? Output : Node
        >
      | undefined
      | void
```

See [`Transformer`][api-transformer] for more info.

###### Example

`move.js`:

```js
/**
 * @typedef Options
 *   Configuration (required).
 * @property {string} extname
 *   File extension to use (must start with `.`).
 */

/** @type {import('unified').Plugin<[Options]>} */
export function move(options) {
  if (!options || !options.extname) {
    throw new Error('Missing `options.extname`')
  }

  return function (_, file) {
    if (file.extname && file.extname !== options.extname) {
      file.extname = options.extname
    }
  }
}
```

`example.md`:

```markdown
# Hello, world!
```

`example.js`:

```js
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import {read, write} from 'to-vfile'
import {unified} from 'unified'
import {reporter} from 'vfile-reporter'
import {move} from './move.js'

const file = await unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(move, {extname: '.html'})
  .use(rehypeStringify)
  .process(await read('example.md'))

console.error(reporter(file))
await write(file) // Written to `example.html`.
```

Yields:

```txt
example.md: no issues found
```

‚Ä¶and in `example.html`:

```html
<h1>Hello, world!</h1>
```

### `PluginTuple`

Tuple of a plugin and its configuration (TypeScript type).

The first item is a plugin, the rest are its parameters.

###### Type

```ts
type PluginTuple<
  TupleParameters extends unknown[] = [],
  Input extends Node | string | undefined = undefined,
  Output = undefined
> = [
  plugin: Plugin<TupleParameters, Input, Output>,
  ...parameters: TupleParameters
]
```

See [`Plugin`][api-plugin] for more info.

### `Preset`

Sharable configuration (TypeScript type).

They can contain plugins and settings.

###### Fields

* `plugins` ([`PluggableList`][api-pluggable-list], optional)
  ‚Äî list of plugins and presets
* `settings` ([`Data`][api-data], optional)
  ‚Äî shared settings for parsers and compilers

###### Example

`preset.js`:

```js
import remarkCommentConfig from 'remark-comment-config'
import remarkLicense from 'remark-license'
import remarkPresetLintConsistent from 'remark-preset-lint-consistent'
import remarkPresetLintRecommended from 'remark-preset-lint-recommended'
import remarkToc from 'remark-toc'

/** @type {import('unified').Preset} */
const preset = {
  plugins: [
    remarkPresetLintRecommended,
    remarkPresetLintConsistent,
    remarkCommentConfig,
    [remarkToc, {maxDepth: 3, tight: true}],
    remarkLicense
  ]
  settings: {bullet: '*', emphasis: '*', fences: true},
}

export default preset
```

`example.md`:

```markdown
# Hello, world!

_Emphasis_ and **importance**.

## Table of contents

## API

## License
```

`example.js`:

```js
import {remark} from 'remark'
import {read, write} from 'to-vfile'
import {reporter} from 'vfile-reporter'
import preset from './preset.js'

const file = await remark()
  .use(preset)
  .process(await read('example.md'))

console.error(reporter(file))
await write(file)
```

Yields:

```txt
example.md: no issues found
```

`example.md` now contains:

```markdown
# Hello, world!

*Emphasis* and **importance**.

## Table of contents

*   [API](#api)
*   [License](#license)

## API

## License

[MIT](license) ¬© [Titus Wormer](https://wooorm.com)
```

### `ProcessCallback`

Callback called when the process is done (TypeScript type).

Called with either an error or a result.

###### Parameters

* `error` (`Error`, optional)
  ‚Äî fatal error
* `file` ([`VFile`][vfile], optional)
  ‚Äî processed file

###### Returns

Nothing (`undefined`).

###### Example

This example shows how `process` can be used to process a file with a callback.

```js
import remarkGithub from 'remark-github'
import remarkParse from 'remark-parse'
import remarkStringify from 'remark-stringify'
import {unified} from 'unified'
import {reporter} from 'vfile-reporter'

unified()
  .use(remarkParse)
  .use(remarkGithub)
  .use(remarkStringify)
  .process('@unifiedjs', function (error, file) {
    if (error) throw error
    if (file) {
      console.error(reporter(file))
      console.log(String(file))
    }
  })
```

Yields:

```txt
no issues found
```

```markdown
[**@unifiedjs**](https://github.com/unifiedjs)
```

### `Processor`

Type of a [`processor`][api-processor] (TypeScript type).

### `RunCallback`

Callback called when transformers are done (TypeScript type).

Called with either an error or results.

###### Parameters

* `error` (`Error`, optional)
  ‚Äî fatal error
* `tree` ([`Node`][node], optional)
  ‚Äî transformed tree
* `file` ([`VFile`][vfile], optional)
  ‚Äî file

###### Returns

Nothing (`undefined`).

### `Settings`

Interface of known extra options, that can be supported by parser and
compilers.

This exists so that users can use packages such as `remark`, which configure
both parsers and compilers (in this case `remark-parse` and
`remark-stringify`), and still provide options for them.

When you make parsers or compilers, that could be packaged up together, you
should support `this.data('settings')` as input and merge it with explicitly
passed `options`.
Then, to type it, using `remark-stringify` as an example, do something like:

```ts
declare module 'unified' {
  interface Settings {
    bullet: '*' | '+' | '-'
    // ‚Ä¶
  }
}

export {} // You may not need this, but it makes sure the file is a module.
```

###### Type

```ts
interface Settings {}
```

### `TransformCallback`

Callback passed to transforms (TypeScript type).

If the signature of a `transformer` accepts a third argument, the transformer
may perform asynchronous operations, and must call it.

###### Parameters

* `error` (`Error`, optional)
  ‚Äî fatal error to stop the process
* `tree` ([`Node`][node], optional)
  ‚Äî new, changed, tree
* `file` ([`VFile`][vfile], optional)
  ‚Äî new, changed, file

###### Returns

Nothing (`undefined`).

### `Transformer`

Transformers handle syntax trees and files (TypeScript type).

They are functions that are called each time a syntax tree and file are
passed through the run phase.
When an error occurs in them (either because it‚Äôs thrown, returned,
rejected, or passed to `next`), the process stops.

The run phase is handled by [`trough`][trough], see its documentation for
the exact semantics of these functions.

> üëâ **Note**: you should likely ignore `next`: don‚Äôt accept it.
> it supports callback-style async work.
> But promises are likely easier to reason about.

###### Type

```ts
type Transformer<
  Input extends Node = Node,
  Output extends Node = Input
> = (
  tree: Input,
  file: VFile,
  next: TransformCallback<Output>
) =>
  | Promise<Output | undefined>
  | Output
  | Error
  | undefined
```

## Types

This package is fully typed with [TypeScript][].
It exports the additional types
[`CompileResultMap`][api-compile-result-map],
[`CompileResults`][api-compile-results],
[`Compiler`][api-compiler],
[`Data`][api-data],
[`Parser`][api-parser],
[`Pluggable`][api-pluggable],
[`PluggableList`][api-pluggable-list],
[`Plugin`][api-plugin],
[`PluginTuple`][api-plugin-tuple],
[`Preset`][api-preset],
[`ProcessCallback`][api-process-callback],
[`Processor`][api-processor],
[`RunCallback`][api-run-callback],
[`Settings`][api-settings],
[`TransformCallback`][api-transform-callback],
and [`Transformer`][api-transformer]

For TypeScript to work, it is particularly important to type your plugins
correctly.
We strongly recommend using the `Plugin` type with its generics and to use the
node types for the syntax trees provided by our packages (as in,
[`@types/hast`][types-hast], [`@types/mdast`][types-mdast],
[`@types/nlcst`][types-nlcst]).

```js
/**
 * @typedef {import('hast').Root} HastRoot
 * @typedef {import('mdast').Root} MdastRoot
 */

/**
 * @typedef Options
 *   Configuration (optional).
 * @property {boolean | null | undefined} [someField]
 *   Some option (optional).
 */

// To type options:
/** @type {import('unified').Plugin<[(Options | null | undefined)?]>} */
export function myPluginAcceptingOptions(options) {
  const settings = options || {}
  // `settings` is now `Options`.
}

// To type a plugin that works on a certain tree, without options:
/** @type {import('unified').Plugin<[], MdastRoot>} */
export function myRemarkPlugin() {
  return function (tree, file) {
    // `tree` is `MdastRoot`.
  }
}

// To type a plugin that transforms one tree into another:
/** @type {import('unified').Plugin<[], MdastRoot, HastRoot>} */
export function remarkRehype() {
  return function (tree) {
    // `tree` is `MdastRoot`.
    // Result must be `HastRoot`.
  }
}

// To type a plugin that defines a parser:
/** @type {import('unified').Plugin<[], string, MdastRoot>} */
export function remarkParse(options) {}

// To type a plugin that defines a compiler:
/** @type {import('unified').Plugin<[], HastRoot, string>} */
export function rehypeStringify(options) {}
```

## Compatibility

Projects maintained by the unified collective are compatible with maintained
versions of Node.js.

When we cut a new major release, we drop support for unmaintained versions of
Node.
This means we try to keep the current release line, `unified@^11`, compatible
with Node.js 16.

## Contribute

See [`contributing.md`][contributing] in [`unifiedjs/.github`][health] for ways
to get started.
See [`support.md`][support] for ways to get help.

This project has a [code of conduct][coc].
By interacting with this repository, organization, or community you agree to
abide by its terms.

For info on how to submit a security report, see our
[security policy][security].

## Sponsor

Support this effort and give back by sponsoring on [OpenCollective][collective]!

>>>>>>> 08f40ceb (Initial)
<table>
<tr valign="middle">
<td width="20%" align="center" rowspan="2" colspan="2">
  <a href="https://vercel.com">Vercel</a><br><br>
  <a href="https://vercel.com"><img src="https://avatars1.githubusercontent.com/u/14985020?s=256&v=4" width="128"></a>
</td>
<td width="20%" align="center" rowspan="2" colspan="2">
  <a href="https://motif.land">Motif</a><br><br>
  <a href="https://motif.land"><img src="https://avatars1.githubusercontent.com/u/74457950?s=256&v=4" width="128"></a>
</td>
<td width="20%" align="center" rowspan="2" colspan="2">
  <a href="https://www.hashicorp.com">HashiCorp</a><br><br>
  <a href="https://www.hashicorp.com"><img src="https://avatars1.githubusercontent.com/u/761456?s=256&v=4" width="128"></a>
</td>
<td width="20%" align="center" rowspan="2" colspan="2">
  <a href="https://americanexpress.io">American Express</a><br><br>
  <a href="https://americanexpress.io"><img src="https://avatars1.githubusercontent.com/u/3853301?s=256&v=4" width="128"></a>
</td>
<td width="20%" align="center" rowspan="2" colspan="2">
  <a href="https://www.gitbook.com">GitBook</a><br><br>
  <a href="https://www.gitbook.com"><img src="https://avatars1.githubusercontent.com/u/7111340?s=256&v=4" width="128"></a>
</td>
</tr>
<tr valign="middle">
</tr>
<tr valign="middle">
<td width="20%" align="center" rowspan="2" colspan="2">
  <a href="https://www.gatsbyjs.org">Gatsby</a><br><br>
  <a href="https://www.gatsbyjs.org"><img src="https://avatars1.githubusercontent.com/u/12551863?s=256&v=4" width="128"></a>
</td>
<td width="20%" align="center" rowspan="2" colspan="2">
  <a href="https://www.netlify.com">Netlify</a><br><br>
  <!--OC has a sharper image-->
  <a href="https://www.netlify.com"><img src="https://images.opencollective.com/netlify/4087de2/logo/256.png" width="128"></a>
</td>
<td width="10%" align="center">
  <a href="https://www.coinbase.com">Coinbase</a><br><br>
  <a href="https://www.coinbase.com"><img src="https://avatars1.githubusercontent.com/u/1885080?s=256&v=4" width="64"></a>
</td>
<td width="10%" align="center">
  <a href="https://themeisle.com">ThemeIsle</a><br><br>
  <a href="https://themeisle.com"><img src="https://avatars1.githubusercontent.com/u/58979018?s=128&v=4" width="64"></a>
</td>
<td width="10%" align="center">
  <a href="https://expo.io">Expo</a><br><br>
  <a href="https://expo.io"><img src="https://avatars1.githubusercontent.com/u/12504344?s=128&v=4" width="64"></a>
</td>
<td width="10%" align="center">
  <a href="https://boostnote.io">Boost Note</a><br><br>
  <a href="https://boostnote.io"><img src="https://images.opencollective.com/boosthub/6318083/logo/128.png" width="64"></a>
</td>
<td width="10%" align="center">
<<<<<<< HEAD
  <a href="https://www.holloway.com">Holloway</a><br><br>
  <a href="https://www.holloway.com"><img src="https://avatars1.githubusercontent.com/u/35904294?s=128&v=4" width="64"></a>
</td>
<td width="10%"></td>
=======
  <a href="https://markdown.space">Markdown Space</a><br><br>
  <a href="https://markdown.space"><img src="https://images.opencollective.com/markdown-space/e1038ed/logo/128.png" width="64"></a>
</td>
<td width="10%" align="center">
  <a href="https://www.holloway.com">Holloway</a><br><br>
  <a href="https://www.holloway.com"><img src="https://avatars1.githubusercontent.com/u/35904294?s=128&v=4" width="64"></a>
</td>
>>>>>>> 08f40ceb (Initial)
</tr>
<tr valign="middle">
<td width="100%" align="center" colspan="6">
  <br>
  <a href="https://opencollective.com/unified"><strong>You?</strong></a>
  <br><br>
</td>
</tr>
</table>

<<<<<<< HEAD
## Install

This package is [ESM only](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c):
Node 12+ is needed to use it and it must be `import`ed instead of `require`d.

[npm][]:

```sh
npm install unified
```

## Use

```js
import {unified} from 'unified'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import rehypeDocument from 'rehype-document'
import rehypeFormat from 'rehype-format'
import rehypeStringify from 'rehype-stringify'
import {reporter} from 'vfile-reporter'

unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeDocument, {title: 'üëãüåç'})
  .use(rehypeFormat)
  .use(rehypeStringify)
  .process('# Hello world!')
  .then(
    (file) => {
      console.error(reporter(file))
      console.log(String(file))
    },
    (error) => {
      // Handle your error here!
      throw error
    }
  )
```

Yields:

```txt
no issues found
```

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>üëãüåç</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
```

## Contents

*   [Description](#description)
*   [API](#api)
    *   [`processor()`](#processor)
    *   [`processor.use(plugin[, options])`](#processoruseplugin-options)
    *   [`processor.parse(file)`](#processorparsefile)
    *   [`processor.stringify(node[, file])`](#processorstringifynode-file)
    *   [`processor.run(node[, file][, done])`](#processorrunnode-file-done)
    *   [`processor.runSync(node[, file])`](#processorrunsyncnode-file)
    *   [`processor.process(file[, done])`](#processorprocessfile-done)
    *   [`processor.processSync(file|value)`](#processorprocesssyncfilevalue)
    *   [`processor.data([key[, value]])`](#processordatakey-value)
    *   [`processor.freeze()`](#processorfreeze)
*   [`Plugin`](#plugin)
    *   [`function attacher([options])`](#function-attacheroptions)
    *   [`function transformer(node, file[, next])`](#function-transformernode-file-next)
*   [`Preset`](#preset)
*   [Contribute](#contribute)
*   [Acknowledgments](#acknowledgments)
*   [License](#license)

## Description

**unified** is an interface for processing text using syntax trees.
Syntax trees are a representation of text understandable to programs.
Those programs, called [*plugin*][plugin]s, take these trees and inspect and
modify them.
To get to the syntax tree from text, there is a [*parser*][parser].
To get from that back to text, there is a [*compiler*][compiler].
This is the [*process*][process] of a *processor*.

```ascii
| ........................ process ........................... |
| .......... parse ... | ... run ... | ... stringify ..........|

          +--------+                     +----------+
Input ->- | Parser | ->- Syntax Tree ->- | Compiler | ->- Output
          +--------+          |          +----------+
                              X
                              |
                       +--------------+
                       | Transformers |
                       +--------------+
```

###### Processors

Every **processor** implements another processor.
To create a processor, call another processor.
The new processor is configured to work the same as its ancestor.
But when the descendant processor is configured in the future it does not affect
the ancestral processor.

When processors are exposed from a module (for example, `unified` itself) they
should not be configured directly, as that would change their behavior for all
module users.
Those processors are [*frozen*][freeze] and they should be called to create a
new processor before they are used.

###### Syntax trees

The **syntax trees** used in **unified** are [**unist**][unist] nodes.
A [**node**][node] is a plain JavaScript objects with a `type` field.
The semantics of nodes and format of syntax trees is defined by other projects.

There are several [*utilities*][unist-utilities] for working with nodes.

*   [**esast**][esast] ‚Äî JS
*   [**hast**][hast] ‚Äî HTML
*   [**mdast**][mdast] ‚Äî Markdown
*   [**nlcst**][nlcst] ‚Äî Natural language
*   [**xast**][xast] ‚Äî XML

###### List of processors

The following projects process different [*syntax tree*][syntax-tree] formats.
They parse text to a syntax tree and compile that back to text.
These processors can be used as is, or their parser and compiler can be mixed
and matched with **unified** and plugins to process between different syntaxes.

*   [**rehype**][rehype] ([*hast*][hast]) ‚Äî HTML
*   [**remark**][remark] ([*mdast*][mdast]) ‚Äî Markdown
*   [**retext**][retext] ([*nlcst*][nlcst]) ‚Äî Natural language

###### List of plugins

The below [**plugins**][plugin] work with **unified**, on all [*syntax
tree*][syntax-tree] formats:

*   [`unified-diff`](https://github.com/unifiedjs/unified-diff)
    ‚Äî Ignore messages for unchanged lines in Travis
*   [`unified-message-control`](https://github.com/unifiedjs/unified-message-control)
    ‚Äî Enable, disable, and ignore messages

See [**remark**][remark-plugins], [**rehype**][rehype-plugins], and
[**retext**][retext-plugins] for their lists of plugins.

###### File

When processing a document, **metadata** is often gathered about that document.
[**vfile**][vfile] is a virtual file format that stores data, metadata, and
messages about files for **unified** and its plugins.

There are several [*utilities*][vfile-utilities] for working with these files.

###### Configuration

[*Processors*][processors] are configured with [*plugin*][plugin]s or
with the [`data`][data] method.

###### Integrations

**unified** can integrate with the file system with [`unified-engine`][engine].
CLI apps can be created with [`unified-args`][args], Gulp plugins with
[`unified-engine-gulp`][gulp], and Atom Linters with
[`unified-engine-atom`][atom].

[`unified-stream`][stream] provides a streaming interface.

###### Programming interface

The API provided by **unified** allows multiple files to be processed and gives
access to *metadata* (such as lint messages):

```js
import {unified} from 'unified'
import remarkParse from 'remark-parse'
import remarkPresetLintMarkdownStyleGuide from 'remark-preset-lint-markdown-style-guide'
import remarkRetext from 'remark-retext'
import retextEnglish from 'retext-english'
import retextEquality from 'retext-equality'
import remarkRehype from 'remark-rehype'
import rehypeStringify from 'rehype-stringify'
import {reporter} from 'vfile-reporter'

unified()
  .use(remarkParse)
  .use(remarkPresetLintMarkdownStyleGuide)
  .use(remarkRetext, unified().use(retextEnglish).use(retextEquality))
  .use(remarkRehype)
  .use(rehypeStringify)
  .process('*Emphasis* and _stress_, you guys!')
  .then(
    (file) => {
      console.error(reporter(file))
      console.log(String(file))
    },
    (error) => {
      // Handle your error here!
      throw error
    }
  )
```

Yields:

```txt
  1:16-1:24  warning  Emphasis should use `*` as a marker                                  emphasis-marker  remark-lint
  1:30-1:34  warning  `guys` may be insensitive, use `people`, `persons`, `folks` instead  gals-man         retext-equality

‚ö† 2 warnings
```

```html
<p><em>Emphasis</em> and <em>stress</em>, you guys!</p>
```

###### Processing between syntaxes

[*Processors*][processors] can be combined in two modes.

**Bridge** mode transforms the [*syntax tree*][syntax-tree] from one format
(*origin*) to another (*destination*).
Another processor runs on the destination tree.
Finally, the original processor continues transforming the origin tree.

**Mutate** mode also transforms the syntax tree from one format to another.
But the original processor continues transforming the destination tree.

In the previous example (‚ÄúProgramming interface‚Äù), `remark-retext` is used in
*bridge* mode: the origin syntax tree is kept after [**retext**][retext] is
done; whereas `remark-rehype` is used in *mutate* mode: it sets a new syntax
tree and discards the origin tree.

*   [`remark-retext`][remark-retext]
*   [`remark-rehype`][remark-rehype]
*   [`rehype-retext`][rehype-retext]
*   [`rehype-remark`][rehype-remark]

## API

This package exports the following identifiers: `unified`.
There is no default export.

### `processor()`

[*Processor*][processors] describing how to *process* text.

###### Returns

`Function` ‚Äî New [*unfrozen*][freeze] processor that is configured to work the
same as its ancestor.
When the descendant processor is configured in the future it does not affect the
ancestral processor.

###### Example

The following example shows how a new processor can be created (from the remark
processor) and linked to **stdin**(4) and **stdout**(4).

```js
import {remark} from 'remark'
import concatStream from 'concat-stream'

process.stdin.pipe(
  concatStream((buf) => {
    process.stdout.write(remark().processSync(buf).toString())
  })
)
```

### `processor.use(plugin[, options])`

[*Configure*][configuration] the processor to use a [*plugin*][plugin] and
optionally configure that plugin with options.

If the processor is already using this plugin, the previous plugin configuration
is changed based on the options that are passed in.
The plugin is not added a second time.

###### Signatures

*   `processor.use(plugin[, options])`
*   `processor.use(preset)`
*   `processor.use(list)`

###### Parameters

*   `plugin` ([`Attacher`][plugin])
*   `options` (`*`, optional) ‚Äî Configuration for `plugin`
*   `preset` (`Object`) ‚Äî Object with an optional `plugins` (set to `list`),
    and/or an optional `settings` object
*   `list` (`Array`) ‚Äî List of plugins, presets, and pairs (`plugin` and
    `options` in an array)

###### Returns

`processor` ‚Äî The processor that `use` was called on.

###### Note

`use` cannot be called on [*frozen*][freeze] processors.
Call the processor first to create a new unfrozen processor.

###### Example

There are many ways to pass plugins to `.use()`.
The below example gives an overview.

```js
import {unified} from 'unified'

unified()
  // Plugin with options:
  .use(pluginA, {x: true, y: true})
  // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
  .use(pluginA, {y: false, z: true})
  // Plugins:
  .use([pluginB, pluginC])
  // Two plugins, the second with options:
  .use([pluginD, [pluginE, {}]])
  // Preset with plugins and settings:
  .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
  // Settings only:
  .use({settings: {position: false}})
```

### `processor.parse(file)`

Parse text to a [*syntax tree*][syntax-tree].

###### Parameters

*   `file` ([`VFile`][vfile]) ‚Äî [*File*][file], any value accepted by `vfile()`

###### Returns

[`Node`][node] ‚Äî Parsed [*syntax tree*][syntax-tree] representing `file`.

###### Note

`parse` freezes the processor if not already [*frozen*][freeze].

`parse` performs the [*parse phase*][description], not the *run phase* or other
phases.

###### Example

The below example shows how `parse` can be used to create a syntax tree from a
file.

```js
import {unified} from 'unified'
import remarkParse from 'remark-parse'

const tree = unified().use(remarkParse).parse('# Hello world!')

console.log(tree)
```

Yields:

```js
{
  type: 'root',
  children: [
    {type: 'heading', depth: 1, children: [Array], position: [Position]}
  ],
  position: {
    start: {line: 1, column: 1, offset: 0},
    end: {line: 1, column: 15, offset: 14}
  }
}
```

#### `processor.Parser`

A **parser** handles the parsing of text to a [*syntax tree*][syntax-tree].
Used in the [*parse phase*][description] and called with a `string` and
[`VFile`][vfile] representation of the text to parse.

`Parser` can be a function, in which case it must return a [`Node`][node]: the
syntax tree representation of the given file.

`Parser` can also be a constructor function (a function with a `parse` field, or
other fields, in its `prototype`), in which case it‚Äôs constructed with `new`.
Instances must have a `parse` method that is called without arguments and must
return a [`Node`][node].

### `processor.stringify(node[, file])`

Compile a [*syntax tree*][syntax-tree].

###### Parameters

*   `node` ([`Node`][node]) ‚Äî [*Syntax tree*][syntax-tree] to compile
*   `file` ([`VFile`][vfile], optional) ‚Äî [*File*][file], any value accepted by
    `vfile()`

###### Returns

`string` or `Buffer` (see notes) ‚Äî Textual representation of the [*syntax
tree*][syntax-tree]

###### Note

`stringify` freezes the processor if not already [*frozen*][freeze].

`stringify` performs the [*stringify phase*][description], not the *run phase*
or other phases.

unified typically compiles by serializing: most [*compiler*][compiler]s return
`string` (or `Buffer`).
Some compilers, such as the one configured with [`rehype-react`][rehype-react],
return other values (in this case, a React tree).
If you‚Äôre using a compiler doesn‚Äôt serialize, expect different result values.
When using TypeScript, cast the type on your side.

###### Example

The below example shows how `stringify` can be used to serialize a syntax tree.

```js
import {unified} from 'unified'
import rehypeStringify from 'rehype-stringify'
import {h} from 'hastscript'

const tree = h('h1', 'Hello world!')

const doc = unified().use(rehypeStringify).stringify(tree)

console.log(doc)
```

Yields:

```html
<h1>Hello world!</h1>
```

#### `processor.Compiler`

A **compiler** handles the compiling of a [*syntax tree*][syntax-tree] to text.
Used in the [*stringify phase*][description] and called with a [`Node`][node]
and [`VFile`][file] representation of syntax tree to compile.

`Compiler` can be a function, in which case it should return a `string`: the
textual representation of the syntax tree.

`Compiler` can also be a constructor function (a function with a `compile`
field, or other fields, in its `prototype`), in which case it‚Äôs constructed with
`new`.
Instances must have a `compile` method that is called without arguments and
should return a `string`.

### `processor.run(node[, file][, done])`

Run [*transformers*][transformer] on a [*syntax tree*][syntax-tree].

###### Parameters

*   `node` ([`Node`][node]) ‚Äî [*Syntax tree*][syntax-tree] to run on
*   `file` ([`VFile`][vfile], optional) ‚Äî [*File*][file], any value accepted by
    `vfile()`
*   `done` ([`Function`][run-done], optional) ‚Äî Callback

###### Returns

[`Promise`][promise] if `done` is not given.
The returned promise is rejected with a fatal error, or resolved with the
transformed [*syntax tree*][syntax-tree].

###### Note

`run` freezes the processor if not already [*frozen*][freeze].

`run` performs the [*run phase*][description], not other phases.

#### `function done(err[, node, file])`

Callback called when [*transformers*][transformer] are done.
Called with either an error or results.

###### Parameters

*   `err` (`Error`, optional) ‚Äî Fatal error
*   `node` ([`Node`][node], optional) ‚Äî Transformed [*syntax tree*][syntax-tree]
*   `file` ([`VFile`][vfile], optional) ‚Äî [*File*][file]

###### Example

The below example shows how `run` can be used to transform a syntax tree.

```js
import {unified} from 'unified'
import remarkReferenceLinks from 'remark-reference-links'
import {u} from 'unist-builder'

const tree = u('root', [
  u('paragraph', [
    u('link', {href: 'https://example.com'}, [u('text', 'Example Domain')])
  ])
])

unified()
  .use(remarkReferenceLinks)
  .run(tree)
  .then(
    (changedTree) => console.log(changedTree),
    (error) => {
      // Handle your error here!
      throw error
    }
  )
```

Yields:

```js
{
  type: 'root',
  children: [
    {type: 'paragraph', children: [Array]},
    {type: 'definition', identifier: '1', title: undefined, url: undefined}
  ]
}
```

### `processor.runSync(node[, file])`

Run [*transformers*][transformer] on a [*syntax tree*][syntax-tree].

An error is thrown if asynchronous [*plugin*][plugin]s are configured.

###### Parameters

*   `node` ([`Node`][node]) ‚Äî [*Syntax tree*][syntax-tree] to run on
*   `file` ([`VFile`][vfile], optional) ‚Äî [*File*][file], any value accepted by
    `vfile()`

###### Returns

[`Node`][node] ‚Äî Transformed [*syntax tree*][syntax-tree].

###### Note

`runSync` freezes the processor if not already [*frozen*][freeze].

`runSync` performs the [*run phase*][description], not other phases.

### `processor.process(file[, done])`

[*Process*][description] the given [*file*][file] as configured on the
processor.

###### Parameters

*   `file` ([`VFile`][vfile]) ‚Äî [*File*][file], any value accepted by `vfile()`
*   `done` ([`Function`][process-done], optional) ‚Äî Callback

###### Returns

[`Promise`][promise] if `done` is not given.
The returned promise is rejected with a fatal error, or resolved with the
processed [*file*][file].

The parsed, transformed, and compiled value is exposed on
[`file.value`][vfile-value] or `file.result` (see notes).

###### Note

`process` freezes the processor if not already [*frozen*][freeze].

`process` performs the [*parse*, *run*, and *stringify* phases][description].

unified typically compiles by serializing: most [*compiler*][compiler]s return
`string` (or `Buffer`).
Some compilers, such as the one configured with [`rehype-react`][rehype-react],
return other values (in this case, a React tree).
If you‚Äôre using a compiler that serializes, the result is available at
`file.value`.
Otherwise, the result is available at `file.result`.

###### Example

The below example shows how `process` can be used to process a file, whether
transformers are asynchronous or not, with promises.

```js
import {unified} from 'unified'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import rehypeDocument from 'rehype-document'
import rehypeFormat from 'rehype-format'
import rehypeStringify from 'rehype-stringify'

unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeDocument, {title: 'üëãüåç'})
  .use(rehypeFormat)
  .use(rehypeStringify)
  .process('# Hello world!')
  .then(
    (file) => console.log(String(file)),
    (error) => {
      // Handle your error here!
      throw error
    }
  )
```

Yields:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>üëãüåç</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
```

#### `function done(err, file)`

Callback called when the [*process*][description] is done.
Called with a fatal error, if any, and a [*file*][file].

###### Parameters

*   `err` (`Error`, optional) ‚Äî Fatal error
*   `file` ([`VFile`][vfile]) ‚Äî Processed [*file*][file]

###### Example

The below example shows how `process` can be used to process a file, whether
transformers are asynchronous or not, with a callback.

```js
import {unified} from 'unified'
import remarkParse from 'remark-parse'
import remarkGithub from 'remark-github'
import remarkStringify from 'remark-stringify'
import {reporter} from 'vfile-reporter'

unified()
  .use(remarkParse)
  .use(remarkGithub)
  .use(remarkStringify)
  .process('@unifiedjs')
  .then(
    (file) => {
      console.error(reporter(file))
      console.log(String(file))
    },
    (error) => {
      // Handle your error here!
      throw error
    }
  )
```

Yields:

```txt
no issues found
```

```markdown
[**@unifiedjs**](https://github.com/unifiedjs)
```

### `processor.processSync(file|value)`

[*Process*][description] the given [*file*][file] as configured on the
processor.

An error is thrown if asynchronous [*plugin*][plugin]s are configured.

###### Parameters

*   `file` ([`VFile`][vfile]) ‚Äî [*File*][file], any value accepted by `vfile()`

###### Returns

([`VFile`][vfile]) ‚Äî Processed [*file*][file]

The parsed, transformed, and compiled value is exposed on
[`file.value`][vfile-value] or `file.result` (see notes).

###### Note

`processSync` freezes the processor if not already [*frozen*][freeze].

`processSync` performs the [*parse*, *run*, and *stringify*
phases][description].

unified typically compiles by serializing: most [*compiler*][compiler]s return
`string` (or `Buffer`).
Some compilers, such as the one configured with [`rehype-react`][rehype-react],
return other values (in this case, a React tree).
If you‚Äôre using a compiler that serializes, the result is available at
`file.value`.
Otherwise, the result is available at `file.result`.

###### Example

The below example shows how `processSync` can be used to process a file, if all
transformers are synchronous.

```js
import {unified} from 'unified'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import rehypeDocument from 'rehype-document'
import rehypeFormat from 'rehype-format'
import rehypeStringify from 'rehype-stringify'

const processor = unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeDocument, {title: 'üëãüåç'})
  .use(rehypeFormat)
  .use(rehypeStringify)

console.log(processor.processSync('# Hello world!').toString())
```

Yields:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>üëãüåç</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
```

### `processor.data([key[, value]])`

[*Configure*][configuration] the processor with information available to all
[*plugin*][plugin]s.
Information is stored in an in-memory key-value store.

Typically, options can be given to a specific plugin, but sometimes it makes
sense to have information shared with several plugins.
For example, a list of HTML elements that are self-closing, which is needed
during all [*phases*][description] of the *process*.

###### Signatures

*   `processor = processor.data(key, value)`
*   `processor = processor.data(values)`
*   `value = processor.data(key)`
*   `info = processor.data()`

###### Parameters

*   `key` (`string`, optional) ‚Äî Identifier
*   `value` (`*`, optional) ‚Äî Value to set
*   `values` (`Object`, optional) ‚Äî Values to set

###### Returns

*   `processor` ‚Äî If setting, the processor that `data` is called on
*   `value` (`*`) ‚Äî If getting, the value at `key`
*   `info` (`Object`) ‚Äî Without arguments, the key-value store

###### Note

Setting information cannot occur on [*frozen*][freeze] processors.
Call the processor first to create a new unfrozen processor.

###### Example

The following example show how to get and set information:

```js
import {unified} from 'unified'

const processor = unified().data('alpha', 'bravo')

processor.data('alpha') // => 'bravo'

processor.data() // => {alpha: 'bravo'}

processor.data({charlie: 'delta'})

processor.data() // => {charlie: 'delta'}
```

### `processor.freeze()`

**Freeze** a processor.
*Frozen* processors are meant to be extended and not to be configured directly.

Once a processor is frozen it cannot be *unfrozen*.
New processors working the same way can be created by calling the processor.

It‚Äôs possible to freeze processors explicitly by calling `.freeze()`.
Processors freeze implicitly when [`.parse()`][parse], [`.run()`][run],
[`.runSync()`][run-sync], [`.stringify()`][stringify], [`.process()`][process],
or [`.processSync()`][process-sync] are called.

###### Returns

`processor` ‚Äî The processor that `freeze` was called on.

###### Example

The following example, `index.js`, shows how rehype prevents extensions to
itself:

```js
import {unified} from 'unified'
import remarkParse from 'rehype-parse'
import remarkStringify from 'rehype-stringify'

export const rehype = unified().use(remarkParse).use(remarkStringify).freeze()
```

The below example, `a.js`, shows how that processor can be used and configured.

```js
import {rehype} from 'rehype'
import rehypeFormat from 'rehype-format'
// ‚Ä¶

rehype()
  .use(rehypeFormat)
  // ‚Ä¶
```

The below example, `b.js`, shows a similar looking example that operates on the
frozen rehype interface because it does not call `rehype`.
If this behavior was allowed it would result in unexpected behavior so an
error is thrown.
**This is invalid**:

```js
import {rehype} from 'rehype'
import rehypeFormat from 'rehype-format'
// ‚Ä¶

rehype
  .use(rehypeFormat)
  // ‚Ä¶
```

Yields:

```txt
~/node_modules/unified/index.js:426
    throw new Error(
    ^

Error: Cannot call `use` on a frozen processor.
Create a new processor first, by calling it: use `processor()` instead of `processor`.
    at assertUnfrozen (~/node_modules/unified/index.js:426:11)
    at Function.use (~/node_modules/unified/index.js:165:5)
    at ~/b.js:6:4
```

## `Plugin`

**Plugins** [*configure*][configuration] the processors they are applied on in
the following ways:

*   They change the processor: such as the [*parser*][parser], the
    [*compiler*][compiler], or configuring [*data*][data]
*   They specify how to handle [*syntax trees*][syntax-tree] and [*files*][file]

Plugins are a concept.
They materialize as [`attacher`][attacher]s.

###### Example

`move.js`:

```js
export function move(options = {}) {
  const {extname} = options

  if (!extname) {
    throw new Error('Missing `extname` in options')
  }

  return transformer

  function transformer(tree, file) {
    if (file.extname && file.extname !== extname) {
      file.extname = extname
    }
  }
}
```

`index.md`:

```markdown
# Hello, world!
```

`index.js`:

```js
import {unified} from 'unified'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import rehypeStringify from 'rehype-stringify'
import {toVFile} from 'to-vfile'
import {reporter} from 'vfile-reporter'
import {move} from './move.js'

unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(move, {extname: '.html'})
  .use(rehypeStringify)
  .process(toVFile.readSync('index.md'))
  .then(
    (file) => {
      console.error(reporter(file))
      toVFile.writeSync(file) // Written to `index.html`.
    },
    (error) => {
      // Handle your error here!
      throw error
    }
  )
```

Yields:

```txt
index.md: no issues found
```

‚Ä¶and in `index.html`:

```html
<h1>Hello, world!</h1>
```

### `function attacher([options])`

**Attachers** are materialized [*plugin*][plugin]s.
An attacher is a function that can receive options and
[*configures*][configuration] the processor.

Attachers change the processor, such as the [*parser*][parser], the
[*compiler*][compiler], configuring [*data*][data], or by specifying how the
[*syntax tree*][syntax-tree] or [*file*][file] are handled.

###### Context

The context object (`this`) is set to the processor the attacher is applied on.

###### Parameters

*   `options` (`*`, optional) ‚Äî Configuration

###### Returns

[`transformer`][transformer] ‚Äî Optional.

###### Note

Attachers are called when the processor is [*frozen*][freeze], not when they are
applied.

### `function transformer(node, file[, next])`

**Transformers** handle [*syntax tree*][syntax-tree]s and [*file*][file]s.
A transformer is a function that is called each time a syntax tree and file are
passed through the [*run phase*][description].
If an error occurs (either because it‚Äôs thrown, returned, rejected, or passed to
[`next`][next]), the process stops.

The *run phase* is handled by [`trough`][trough], see its documentation for the
exact semantics of these functions.

###### Parameters

*   `node` ([`Node`][node]) ‚Äî [*Syntax tree*][syntax-tree] to handle
*   `file` ([`VFile`][vfile]) ‚Äî [*File*][file] to handle
*   `next` ([`Function`][next], optional)

###### Returns

*   `void` ‚Äî If nothing is returned, the next transformer keeps using same tree.
*   `Error` ‚Äî Fatal error to stop the process
*   `node` ([`Node`][node]) ‚Äî New [*syntax tree*][syntax-tree].
    If returned, the next transformer is given this new tree
*   `Promise` ‚Äî Returned to perform an asynchronous operation.
    The promise **must** be resolved (optionally with a [`Node`][node]) or
    rejected (optionally with an `Error`)

#### `function next(err[, tree[, file]])`

If the signature of a [*transformer*][transformer] includes `next` (the third
argument), the transformer **may** perform asynchronous operations, and **must**
call `next()`.

###### Parameters

*   `err` (`Error`, optional) ‚Äî Fatal error to stop the process
*   `node` ([`Node`][node], optional) ‚Äî New [*syntax tree*][syntax-tree].
    If given, the next transformer is given this new tree
*   `file` ([`VFile`][vfile], optional) ‚Äî New [*file*][file].
    If given, the next transformer is given this new file

## `Preset`

**Presets** are sharable [*configuration*][configuration].
They can contain [*plugins*][plugin] and settings.

###### Example

`preset.js`:

```js
import remarkPresetLintRecommended from 'remark-preset-lint-recommended'
import remarkPresetLintConsistent from 'remark-preset-lint-consistent'
import remarkCommentConfig from 'remark-comment-config'
import remarkToc from 'remark-toc'
import remarkLicense from 'remark-license'

export const preset = {
  settings: {bullet: '*', emphasis: '*', fences: true},
  plugins: [
    remarkPresetLintRecommended,
    remarkPresetLintConsistent,
    remarkCommentConfig,
    [remarkToc, {maxDepth: 3, tight: true}],
    remarkLicense
  ]
}
```

`example.md`:

```markdown
# Hello, world!

_Emphasis_ and **importance**.

## Table of contents

## API

## License
```

`index.js`:

```js
import {remark} from 'remark'
import {toVFile} from 'to-vfile'
import {reporter} from 'vfile-reporter'
import {preset} from './preset.js'

remark()
  .use(preset)
  .process(toVFile.readSync('example.md'))
  .then(
    (file) => {
      console.error(reporter(file))
      toVFile.writeSync(file)
    },
    (error) => {
      // Handle your error here!
      throw error
    }
  )
```

Yields:

```txt
example.md: no issues found
```

`example.md` now contains:

```markdown
# Hello, world!

*Emphasis* and **importance**.

## Table of contents

*   [API](#api)
*   [License](#license)

## API

## License

[MIT](license) ¬© [Titus Wormer](https://wooorm.com)
```

## Contribute

See [`contributing.md`][contributing] in [`unifiedjs/.github`][health] for ways
to get started.
See [`support.md`][support] for ways to get help.
Ideas for new plugins and tools can be posted in [`unifiedjs/ideas`][ideas].

A curated list of awesome unified resources can be found in [**awesome
unified**][awesome].

This project has a [code of conduct][coc].
By interacting with this repository, organization, or community you agree to
abide by its terms.

## Acknowledgments

Preliminary work for unified was done [in 2014][preliminary] for
[**retext**][retext] and inspired by [`ware`][ware].
Further incubation happened in [**remark**][remark].
The project was finally [externalised][] in 2015 and [published][] as `unified`.
The project was authored by [**@wooorm**](https://github.com/wooorm).

Although `unified` since moved its plugin architecture to [`trough`][trough],
thanks to [**@calvinfo**](https://github.com/calvinfo),
[**@ianstormtaylor**](https://github.com/ianstormtaylor), and others for their
=======
## Acknowledgments

Preliminary work for unified was done [in 2014][preliminary] for
**[retext][]** and inspired by [`ware`][ware].
Further incubation happened in **[remark][]**.
The project was finally [externalised][] in 2015 and [published][] as `unified`.
The project was authored by **[@wooorm](https://github.com/wooorm)**.

Although `unified` since moved its plugin architecture to [`trough`][trough],
thanks to **[@calvinfo](https://github.com/calvinfo)**,
**[@ianstormtaylor](https://github.com/ianstormtaylor)**, and others for their
>>>>>>> 08f40ceb (Initial)
work on [`ware`][ware], as it was a huge initial inspiration.

## License

[MIT][license] ¬© [Titus Wormer][author]

<!-- Definitions -->

[logo]: https://raw.githubusercontent.com/unifiedjs/unified/93862e5/logo.svg?sanitize=true

[build-badge]: https://github.com/unifiedjs/unified/workflows/main/badge.svg

[build]: https://github.com/unifiedjs/unified/actions

[coverage-badge]: https://img.shields.io/codecov/c/github/unifiedjs/unified.svg

[coverage]: https://codecov.io/github/unifiedjs/unified

[downloads-badge]: https://img.shields.io/npm/dm/unified.svg

[downloads]: https://www.npmjs.com/package/unified

<<<<<<< HEAD
[size-badge]: https://img.shields.io/bundlephobia/minzip/unified.svg

[size]: https://bundlephobia.com/result?p=unified
=======
[size-badge]: https://img.shields.io/bundlejs/size/unified

[size]: https://bundlejs.com/?q=unified
>>>>>>> 08f40ceb (Initial)

[sponsors-badge]: https://opencollective.com/unified/sponsors/badge.svg

[backers-badge]: https://opencollective.com/unified/backers/badge.svg

[collective]: https://opencollective.com/unified

[chat-badge]: https://img.shields.io/badge/chat-discussions-success.svg

[chat]: https://github.com/unifiedjs/unified/discussions

<<<<<<< HEAD
[health]: https://github.com/unifiedjs/.github

[contributing]: https://github.com/unifiedjs/.github/blob/HEAD/contributing.md

[support]: https://github.com/unifiedjs/.github/blob/HEAD/support.md

[coc]: https://github.com/unifiedjs/.github/blob/HEAD/code-of-conduct.md

[awesome]: https://github.com/unifiedjs/awesome-unified
=======
[esm]: https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c

[esmsh]: https://esm.sh

[typescript]: https://www.typescriptlang.org

[health]: https://github.com/unifiedjs/.github

[contributing]: https://github.com/unifiedjs/.github/blob/main/contributing.md

[support]: https://github.com/unifiedjs/.github/blob/main/support.md

[coc]: https://github.com/unifiedjs/.github/blob/main/code-of-conduct.md

[security]: https://github.com/unifiedjs/.github/blob/main/security.md
>>>>>>> 08f40ceb (Initial)

[license]: license

[author]: https://wooorm.com

[npm]: https://docs.npmjs.com/cli/install

[site]: https://unifiedjs.com

[twitter]: https://twitter.com/unifiedjs

<<<<<<< HEAD
[learn]: https://unifiedjs.com/learn/

=======
>>>>>>> 08f40ceb (Initial)
[rehype]: https://github.com/rehypejs/rehype

[remark]: https://github.com/remarkjs/remark

[retext]: https://github.com/retextjs/retext

<<<<<<< HEAD
=======
[syntax-tree]: https://github.com/syntax-tree

>>>>>>> 08f40ceb (Initial)
[esast]: https://github.com/syntax-tree/esast

[hast]: https://github.com/syntax-tree/hast

[mdast]: https://github.com/syntax-tree/mdast

[nlcst]: https://github.com/syntax-tree/nlcst

<<<<<<< HEAD
[xast]: https://github.com/syntax-tree/xast

[unist]: https://github.com/syntax-tree/unist

[engine]: https://github.com/unifiedjs/unified-engine

[args]: https://github.com/unifiedjs/unified-args

[gulp]: https://github.com/unifiedjs/unified-engine-gulp

[atom]: https://github.com/unifiedjs/unified-engine-atom
=======
[unist]: https://github.com/syntax-tree/unist

[xast]: https://github.com/syntax-tree/xast

[unified-engine]: https://github.com/unifiedjs/unified-engine

[unified-args]: https://github.com/unifiedjs/unified-args

[unified-engine-gulp]: https://github.com/unifiedjs/unified-engine-gulp

[unified-language-server]: https://github.com/unifiedjs/unified-language-server

[unified-stream]: https://github.com/unifiedjs/unified-stream

[rehype-remark]: https://github.com/rehypejs/rehype-remark

[rehype-retext]: https://github.com/rehypejs/rehype-retext
>>>>>>> 08f40ceb (Initial)

[remark-rehype]: https://github.com/remarkjs/remark-rehype

[remark-retext]: https://github.com/remarkjs/remark-retext

<<<<<<< HEAD
[rehype-retext]: https://github.com/rehypejs/rehype-retext

[rehype-remark]: https://github.com/rehypejs/rehype-remark

[unist-utilities]: https://github.com/syntax-tree/unist#list-of-utilities

[vfile]: https://github.com/vfile/vfile

[vfile-value]: https://github.com/vfile/vfile#vfilevalue

[vfile-utilities]: https://github.com/vfile/vfile#list-of-utilities

[node]: https://github.com/syntax-tree/unist#node

[description]: #description

[syntax-tree]: #syntax-trees

[configuration]: #configuration

[file]: #file

[processors]: #processors

[process]: #processorprocessfile-done

[process-sync]: #processorprocesssyncfilevalue

[parse]: #processorparsefile

[parser]: #processorparser

[stringify]: #processorstringifynode-file

[run]: #processorrunnode-file-done

[run-sync]: #processorrunsyncnode-file

[compiler]: #processorcompiler

[data]: #processordatakey-value

[attacher]: #function-attacheroptions

[transformer]: #function-transformernode-file-next

[next]: #function-nexterr-tree-file

[freeze]: #processorfreeze

[plugin]: #plugin

[run-done]: #function-doneerr-node-file

[process-done]: #function-doneerr-file

[contribute]: #contribute

=======
[node]: https://github.com/syntax-tree/unist#node

[vfile]: https://github.com/vfile/vfile

[vfile-compatible]: https://github.com/vfile/vfile#compatible

[vfile-value]: https://github.com/vfile/vfile#value

[vfile-utilities]: https://github.com/vfile/vfile#list-of-utilities

>>>>>>> 08f40ceb (Initial)
[rehype-react]: https://github.com/rehypejs/rehype-react

[trough]: https://github.com/wooorm/trough#function-fninput-next

<<<<<<< HEAD
[promise]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise

[remark-plugins]: https://github.com/remarkjs/remark/blob/HEAD/doc/plugins.md#list-of-plugins

[rehype-plugins]: https://github.com/rehypejs/rehype/blob/HEAD/doc/plugins.md#list-of-plugins

[retext-plugins]: https://github.com/retextjs/retext/blob/HEAD/doc/plugins.md#list-of-plugins

[stream]: https://github.com/unifiedjs/unified-stream

[ideas]: https://github.com/unifiedjs/ideas

[preliminary]: https://github.com/retextjs/retext/commit/8fcb1f#diff-168726dbe96b3ce427e7fedce31bb0bc

[externalised]: https://github.com/remarkjs/remark/commit/9892ec#diff-168726dbe96b3ce427e7fedce31bb0bc
=======
[rehype-plugins]: https://github.com/rehypejs/rehype/blob/main/doc/plugins.md#list-of-plugins

[remark-plugins]: https://github.com/remarkjs/remark/blob/main/doc/plugins.md#list-of-plugins

[retext-plugins]: https://github.com/retextjs/retext/blob/main/doc/plugins.md#list-of-plugins

[awesome-rehype]: https://github.com/rehypejs/awesome-rehype

[awesome-remark]: https://github.com/remarkjs/awesome-remark

[awesome-retext]: https://github.com/retextjs/awesome-retext

[topic-rehype-plugin]: https://github.com/topics/rehype-plugin

[topic-remark-plugin]: https://github.com/topics/remark-plugin

[topic-retext-plugin]: https://github.com/topics/retext-plugin

[types-hast]: https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/hast

[types-mdast]: https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/mdast

[types-nlcst]: https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/nlcst

[preliminary]: https://github.com/retextjs/retext/commit/8fcb1f

[externalised]: https://github.com/remarkjs/remark/commit/9892ec
>>>>>>> 08f40ceb (Initial)

[published]: https://github.com/unifiedjs/unified/commit/2ba1cf

[ware]: https://github.com/segmentio/ware

<<<<<<< HEAD
[gatsby]: https://www.gatsbyjs.org

[mdx]: https://mdxjs.com

[jsx]: https://reactjs.org/docs/jsx-in-depth.html

[prettier]: https://prettier.io

[node.js]: https://nodejs.org

[vercel]: https://vercel.com

[netlify]: https://www.netlify.com

[github]: https://github.com

[mozilla]: https://www.mozilla.org

[wordpress]: https://wordpress.com

[adobe]: https://www.adobe.com

[facebook]: https://www.facebook.com

[google]: https://www.google.com
=======
[api]: #api

[contribute]: #contribute

[overview]: #overview

[sponsor]: #sponsor

[api-compile-result-map]: #compileresultmap

[api-compile-results]: #compileresults

[api-compiler]: #compiler

[api-data]: #data

[api-freeze]: #processorfreeze

[api-parser]: #parser

[api-pluggable]: #pluggable

[api-pluggable-list]: #pluggablelist

[api-plugin]: #plugin

[api-plugin-tuple]: #plugintuple

[api-preset]: #preset

[api-process]: #processorprocessfile-done

[api-process-callback]: #processcallback

[api-processor]: #processor

[api-run-callback]: #runcallback

[api-settings]: #settings

[api-transform-callback]: #transformcallback

[api-transformer]: #transformer
>>>>>>> 08f40ceb (Initial)
