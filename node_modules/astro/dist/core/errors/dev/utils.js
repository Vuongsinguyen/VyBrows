<<<<<<< HEAD
import { escape } from "html-escaper";
import { bold, underline } from "kleur/colors";
import * as fs from "node:fs";
import { isAbsolute, join } from "node:path";
import { fileURLToPath } from "node:url";
import stripAnsi from "strip-ansi";
import { normalizePath } from "vite";
import { removeLeadingForwardSlashWindows } from "../../path.js";
import { AggregateError } from "../errors.js";
=======
import * as fs from "node:fs";
import { isAbsolute, join } from "node:path";
import { fileURLToPath } from "node:url";
import { stripVTControlCharacters } from "node:util";
import { escape } from "html-escaper";
import { bold, underline } from "kleur/colors";
import { removeLeadingForwardSlashWindows } from "../../path.js";
import { normalizePath } from "../../viteUtils.js";
import { AggregateError } from "../errors.js";
import { AstroErrorData } from "../index.js";
>>>>>>> 08f40ceb (Initial)
import { codeFrame } from "../printer.js";
import { normalizeLF } from "../utils.js";
function collectErrorMetadata(e, rootFolder) {
  const err = AggregateError.is(e) || Array.isArray(e.errors) ? e.errors : [e];
  err.forEach((error) => {
<<<<<<< HEAD
    var _a, _b;
    if (e.stack) {
      const stackInfo = collectInfoFromStacktrace(e);
      error.stack = stackInfo.stack;
=======
    if (e.stack) {
      const stackInfo = collectInfoFromStacktrace(e);
      try {
        error.stack = stripVTControlCharacters(stackInfo.stack);
      } catch {
      }
>>>>>>> 08f40ceb (Initial)
      error.loc = stackInfo.loc;
      error.plugin = stackInfo.plugin;
      error.pluginCode = stackInfo.pluginCode;
    }
<<<<<<< HEAD
    const normalizedFile = normalizePath(((_a = error.loc) == null ? void 0 : _a.file) || "");
    const normalizedRootFolder = removeLeadingForwardSlashWindows((rootFolder == null ? void 0 : rootFolder.pathname) || "");
    if (((_b = error.loc) == null ? void 0 : _b.file) && rootFolder && (!(normalizedFile == null ? void 0 : normalizedFile.startsWith(normalizedRootFolder)) || !isAbsolute(normalizedFile))) {
=======
    const normalizedFile = normalizePath(error.loc?.file || "");
    const normalizedRootFolder = removeLeadingForwardSlashWindows(rootFolder?.pathname || "");
    if (error.loc?.file && rootFolder && (!normalizedFile?.startsWith(normalizedRootFolder) || !isAbsolute(normalizedFile))) {
>>>>>>> 08f40ceb (Initial)
      error.loc.file = join(fileURLToPath(rootFolder), error.loc.file);
    }
    if (error.loc && (!error.frame || !error.fullCode)) {
      try {
        const fileContents = fs.readFileSync(error.loc.file, "utf8");
        if (!error.frame) {
          const frame = codeFrame(fileContents, error.loc);
<<<<<<< HEAD
          error.frame = frame;
=======
          error.frame = stripVTControlCharacters(frame);
>>>>>>> 08f40ceb (Initial)
        }
        if (!error.fullCode) {
          error.fullCode = fileContents;
        }
      } catch {
      }
    }
    error.hint = generateHint(e);
<<<<<<< HEAD
  });
  if (!AggregateError.is(e) && Array.isArray(e.errors)) {
    e.errors.forEach((buildError, i) => {
      var _a;
      const { location, pluginName, text } = buildError;
      if (text) {
        err[i].message = text;
      }
      if (location) {
        err[i].loc = { file: location.file, line: location.line, column: location.column };
        err[i].id = err[0].id || (location == null ? void 0 : location.file);
      }
      if (err[i].frame) {
        const errorLines = (_a = err[i].frame) == null ? void 0 : _a.trim().split("\n");
        if (errorLines) {
          err[i].frame = !/^\d/.test(errorLines[0]) ? errorLines == null ? void 0 : errorLines.slice(1).join("\n") : err[i].frame;
        }
      }
      const possibleFilePath = (location == null ? void 0 : location.file) ?? err[i].id;
=======
    if (error.message) {
      try {
        error.message = stripVTControlCharacters(error.message);
      } catch {
      }
    }
  });
  if (!AggregateError.is(e) && Array.isArray(e.errors)) {
    e.errors.forEach((buildError, i) => {
      const { location, pluginName, text } = buildError;
      if (text) {
        try {
          err[i].message = text;
        } catch {
        }
      }
      if (location) {
        err[i].loc = { file: location.file, line: location.line, column: location.column };
        err[i].id = err[0].id || location?.file;
      }
      if (err[i].frame) {
        const errorLines = err[i].frame?.trim().split("\n");
        if (errorLines) {
          err[i].frame = !/^\d/.test(errorLines[0]) ? errorLines?.slice(1).join("\n") : err[i].frame;
        }
      }
      const possibleFilePath = location?.file ?? err[i].id;
>>>>>>> 08f40ceb (Initial)
      if (possibleFilePath && err[i].loc && (!err[i].frame || !err[i].fullCode)) {
        try {
          const fileContents = fs.readFileSync(possibleFilePath, "utf8");
          if (!err[i].frame) {
            err[i].frame = codeFrame(fileContents, { ...err[i].loc, file: possibleFilePath });
          }
          err[i].fullCode = fileContents;
        } catch {
          err[i].fullCode = err[i].pluginCode;
        }
      }
      if (pluginName) {
        err[i].plugin = pluginName;
      }
      err[i].hint = generateHint(err[0]);
    });
  }
  return err[0];
}
function generateHint(err) {
<<<<<<< HEAD
  var _a, _b;
  const commonBrowserAPIs = ["document", "window"];
  if (/Unknown file extension \"\.(jsx|vue|svelte|astro|css)\" for /.test(err.message)) {
=======
  const commonBrowserAPIs = ["document", "window"];
  if (/Unknown file extension "\.(?:jsx|vue|svelte|astro|css)" for /.test(err.message)) {
>>>>>>> 08f40ceb (Initial)
    return "You likely need to add this package to `vite.ssr.noExternal` in your astro config file.";
  } else if (commonBrowserAPIs.some((api) => err.toString().includes(api))) {
    const hint = `Browser APIs are not available on the server.

<<<<<<< HEAD
${((_b = (_a = err.loc) == null ? void 0 : _a.file) == null ? void 0 : _b.endsWith(".astro")) ? "Move your code to a <script> tag outside of the frontmatter, so the code runs on the client." : "If the code is in a framework component, try to access these objects after rendering using lifecycle methods or use a `client:only` directive to make the component exclusively run on the client."}
=======
${err.loc?.file?.endsWith(".astro") ? "Move your code to a <script> tag outside of the frontmatter, so the code runs on the client." : "If the code is in a framework component, try to access these objects after rendering using lifecycle methods or use a `client:only` directive to make the component exclusively run on the client."}
>>>>>>> 08f40ceb (Initial)

See https://docs.astro.build/en/guides/troubleshooting/#document-or-window-is-not-defined for more information.
		`;
    return hint;
  }
  return err.hint;
}
function collectInfoFromStacktrace(error) {
<<<<<<< HEAD
  var _a, _b, _c;
=======
>>>>>>> 08f40ceb (Initial)
  let stackInfo = {
    stack: error.stack,
    plugin: error.plugin,
    pluginCode: error.pluginCode,
    loc: error.loc
  };
  stackInfo.stack = normalizeLF(error.stack);
<<<<<<< HEAD
  const stackText = stripAnsi(error.stack);
  if (!stackInfo.loc || !stackInfo.loc.column && !stackInfo.loc.line) {
    const possibleFilePath = ((_a = error.loc) == null ? void 0 : _a.file) || error.pluginCode || error.id || // TODO: this could be better, `src` might be something else
    stackText.split("\n").find((ln) => ln.includes("src") || ln.includes("node_modules"));
    const source = possibleFilePath == null ? void 0 : possibleFilePath.replace(/^[^(]+\(([^)]+).*$/, "$1").replace(/^\s+at\s+/, "");
    let file = source == null ? void 0 : source.replace(/(:[0-9]+)/g, "");
    const location = /:([0-9]+):([0-9]+)/g.exec(source) ?? [];
=======
  const stackText = stripVTControlCharacters(error.stack);
  if (!stackInfo.loc || !stackInfo.loc.column && !stackInfo.loc.line) {
    const possibleFilePath = error.loc?.file || error.pluginCode || error.id || // TODO: this could be better, `src` might be something else
    stackText.split("\n").find((ln) => ln.includes("src") || ln.includes("node_modules"));
    const source = possibleFilePath?.replace?.(/^[^(]+\(([^)]+).*$/, "$1").replace(/^\s+at\s+/, "");
    let file = source?.replace(/:\d+/g, "");
    const location = /:(\d+):(\d+)/.exec(source) ?? [];
>>>>>>> 08f40ceb (Initial)
    const line = location[1];
    const column = location[2];
    if (file && line && column) {
      try {
        file = fileURLToPath(file);
      } catch {
      }
      stackInfo.loc = {
        file,
        line: Number.parseInt(line),
        column: Number.parseInt(column)
      };
    }
  }
  if (!stackInfo.plugin) {
<<<<<<< HEAD
    stackInfo.plugin = ((_b = /withastro\/astro\/packages\/integrations\/([\w-]+)/gim.exec(stackText)) == null ? void 0 : _b.at(1)) || ((_c = /(@astrojs\/[\w-]+)\/(server|client|index)/gim.exec(stackText)) == null ? void 0 : _c.at(1)) || void 0;
=======
    stackInfo.plugin = /withastro\/astro\/packages\/integrations\/([\w-]+)/i.exec(stackText)?.at(1) || /(@astrojs\/[\w-]+)\/(server|client|index)/i.exec(stackText)?.at(1) || void 0;
>>>>>>> 08f40ceb (Initial)
  }
  stackInfo.stack = cleanErrorStack(error.stack);
  return stackInfo;
}
function cleanErrorStack(stack) {
<<<<<<< HEAD
  return stack.split(/\n/g).map((l) => l.replace(/\/@fs\//g, "/")).join("\n");
}
function renderErrorMarkdown(markdown, target) {
  const linkRegex = /\[(.+)\]\((.+)\)/gm;
  const boldRegex = /\*\*(.+)\*\*/gm;
  const urlRegex = / (\b(https?|ftp):\/\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|]) /gim;
  const codeRegex = /`([^`]+)`/gim;
  if (target === "html") {
    return escape(markdown).replace(linkRegex, `<a href="$2" target="_blank">$1</a>`).replace(boldRegex, "<b>$1</b>").replace(urlRegex, ' <a href="$1" target="_blank">$1</a> ').replace(codeRegex, "<code>$1</code>");
  } else {
    return markdown.replace(linkRegex, (fullMatch, m1, m2) => `${bold(m1)} ${underline(m2)}`).replace(urlRegex, (fullMatch) => ` ${underline(fullMatch.trim())} `).replace(boldRegex, (fullMatch, m1) => `${bold(m1)}`);
=======
  return stack.split(/\n/).map((l) => l.replace(/\/@fs\//g, "/")).join("\n");
}
function getDocsForError(err) {
  if (err.name !== "UnknownError" && err.name in AstroErrorData) {
    return `https://docs.astro.build/en/reference/errors/${getKebabErrorName(err.name)}/`;
  }
  return void 0;
  function getKebabErrorName(errorName) {
    return errorName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
}
const linkRegex = /\[([^[]+)\]\((.*)\)/g;
const boldRegex = /\*\*(.+)\*\*/g;
const urlRegex = / ((?:https?|ftp):\/\/[-\w+&@#\\/%?=~|!:,.;]*[-\w+&@#\\/%=~|])/gi;
const codeRegex = /`([^`]+)`/g;
function renderErrorMarkdown(markdown, target) {
  if (target === "html") {
    return escape(markdown).replace(linkRegex, `<a href="$2" target="_blank">$1</a>`).replace(boldRegex, "<b>$1</b>").replace(urlRegex, ' <a href="$1" target="_blank">$1</a>').replace(codeRegex, "<code>$1</code>");
  } else {
    return markdown.replace(linkRegex, (_, m1, m2) => `${bold(m1)} ${underline(m2)}`).replace(urlRegex, (fullMatch) => ` ${underline(fullMatch.trim())}`).replace(boldRegex, (_, m1) => `${bold(m1)}`);
>>>>>>> 08f40ceb (Initial)
  }
}
export {
  collectErrorMetadata,
<<<<<<< HEAD
=======
  getDocsForError,
>>>>>>> 08f40ceb (Initial)
  renderErrorMarkdown
};
