<<<<<<< HEAD
import glob from "fast-glob";
import { join } from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { runHookBuildSsr } from "../../../integrations/index.js";
import { isServerLikeOutput } from "../../../prerender/utils.js";
import { BEFORE_HYDRATION_SCRIPT_ID, PAGE_SCRIPT_ID } from "../../../vite-plugin-scripts/index.js";
import { joinPaths, prependForwardSlash } from "../../path.js";
import { routeIsRedirect } from "../../redirects/index.js";
import { serializeRouteData } from "../../routing/index.js";
import { addRollupInput } from "../add-rollup-input.js";
import { getOutFile, getOutFolder } from "../common.js";
import { cssOrder, mergeInlineCss } from "../internal.js";
import { ASTRO_PAGE_MODULE_ID } from "./plugin-pages.js";
import { RENDERERS_MODULE_ID } from "./plugin-renderers.js";
import { getPathFromVirtualModulePageName, getVirtualModulePageNameFromPath } from "./util.js";
const SSR_VIRTUAL_MODULE_ID = "@astrojs-ssr-virtual-entry";
const RESOLVED_SSR_VIRTUAL_MODULE_ID = "\0" + SSR_VIRTUAL_MODULE_ID;
const manifestReplace = "@@ASTRO_MANIFEST_REPLACE@@";
const replaceExp = new RegExp(`['"](${manifestReplace})['"]`, "g");
=======
import { ASTRO_ACTIONS_INTERNAL_MODULE_ID } from "../../../actions/consts.js";
import { MIDDLEWARE_MODULE_ID } from "../../middleware/vite-plugin.js";
import { routeIsRedirect } from "../../redirects/index.js";
import { VIRTUAL_ISLAND_MAP_ID } from "../../server-islands/vite-plugin-server-islands.js";
import { addRollupInput } from "../add-rollup-input.js";
import { SSR_MANIFEST_VIRTUAL_MODULE_ID } from "./plugin-manifest.js";
import { ASTRO_PAGE_MODULE_ID } from "./plugin-pages.js";
import { RENDERERS_MODULE_ID } from "./plugin-renderers.js";
import { getVirtualModulePageName } from "./util.js";
const SSR_VIRTUAL_MODULE_ID = "@astrojs-ssr-virtual-entry";
const RESOLVED_SSR_VIRTUAL_MODULE_ID = "\0" + SSR_VIRTUAL_MODULE_ID;
const ADAPTER_VIRTUAL_MODULE_ID = "@astrojs-ssr-adapter";
const RESOLVED_ADAPTER_VIRTUAL_MODULE_ID = "\0" + ADAPTER_VIRTUAL_MODULE_ID;
function vitePluginAdapter(adapter) {
  return {
    name: "@astrojs/vite-plugin-astro-adapter",
    enforce: "post",
    resolveId(id) {
      if (id === ADAPTER_VIRTUAL_MODULE_ID) {
        return RESOLVED_ADAPTER_VIRTUAL_MODULE_ID;
      }
    },
    async load(id) {
      if (id === RESOLVED_ADAPTER_VIRTUAL_MODULE_ID) {
        return { code: `export * from ${JSON.stringify(adapter.serverEntrypoint)};` };
      }
    }
  };
}
>>>>>>> 08f40ceb (Initial)
function vitePluginSSR(internals, adapter, options) {
  return {
    name: "@astrojs/vite-plugin-astro-ssr-server",
    enforce: "post",
    options(opts) {
<<<<<<< HEAD
      return addRollupInput(opts, [SSR_VIRTUAL_MODULE_ID]);
=======
      const inputs = /* @__PURE__ */ new Set();
      for (const pageData of Object.values(options.allPages)) {
        if (routeIsRedirect(pageData.route)) {
          continue;
        }
        inputs.add(getVirtualModulePageName(ASTRO_PAGE_MODULE_ID, pageData.component));
      }
      const adapterServerEntrypoint = options.settings.adapter?.serverEntrypoint;
      if (adapterServerEntrypoint) {
        inputs.add(ADAPTER_VIRTUAL_MODULE_ID);
      }
      inputs.add(SSR_VIRTUAL_MODULE_ID);
      return addRollupInput(opts, Array.from(inputs));
>>>>>>> 08f40ceb (Initial)
    },
    resolveId(id) {
      if (id === SSR_VIRTUAL_MODULE_ID) {
        return RESOLVED_SSR_VIRTUAL_MODULE_ID;
      }
    },
    async load(id) {
      if (id === RESOLVED_SSR_VIRTUAL_MODULE_ID) {
        const { allPages } = options;
        const imports = [];
        const contents = [];
        const exports = [];
        let i = 0;
        const pageMap = [];
<<<<<<< HEAD
        for (const [path, pageData] of Object.entries(allPages)) {
          if (routeIsRedirect(pageData.route)) {
            continue;
          }
          const virtualModuleName = getVirtualModulePageNameFromPath(ASTRO_PAGE_MODULE_ID, path);
          let module = await this.resolve(virtualModuleName);
          if (module) {
            const variable = `_page${i}`;
            imports.push(`const ${variable}  = () => import("${virtualModuleName}");`);
            const pageData2 = internals.pagesByComponent.get(path);
=======
        for (const pageData of Object.values(allPages)) {
          if (routeIsRedirect(pageData.route)) {
            continue;
          }
          const virtualModuleName = getVirtualModulePageName(
            ASTRO_PAGE_MODULE_ID,
            pageData.component
          );
          let module = await this.resolve(virtualModuleName);
          if (module) {
            const variable = `_page${i}`;
            imports.push(`const ${variable} = () => import("${virtualModuleName}");`);
            const pageData2 = internals.pagesByKeys.get(pageData.key);
>>>>>>> 08f40ceb (Initial)
            if (pageData2) {
              pageMap.push(`[${JSON.stringify(pageData2.component)}, ${variable}]`);
            }
            i++;
          }
        }
<<<<<<< HEAD
        contents.push(`const pageMap = new Map([${pageMap.join(",")}]);`);
        exports.push(`export { pageMap }`);
        const ssrCode = generateSSRCode(options.settings.config, adapter);
        imports.push(...ssrCode.imports);
        contents.push(...ssrCode.contents);
        return `${imports.join("\n")}${contents.join("\n")}${exports.join("\n")}`;
      }
      return void 0;
=======
        contents.push(`const pageMap = new Map([
    ${pageMap.join(",\n    ")}
]);`);
        exports.push(`export { pageMap }`);
        const middleware = await this.resolve(MIDDLEWARE_MODULE_ID);
        const ssrCode = generateSSRCode(adapter, middleware.id);
        imports.push(...ssrCode.imports);
        contents.push(...ssrCode.contents);
        return { code: [...imports, ...contents, ...exports].join("\n") };
      }
>>>>>>> 08f40ceb (Initial)
    },
    async generateBundle(_opts, bundle) {
      for (const [, chunk] of Object.entries(bundle)) {
        if (chunk.type === "asset") {
          internals.staticFiles.add(chunk.fileName);
        }
      }
<<<<<<< HEAD
      for (const [chunkName, chunk] of Object.entries(bundle)) {
=======
      for (const [, chunk] of Object.entries(bundle)) {
>>>>>>> 08f40ceb (Initial)
        if (chunk.type === "asset") {
          continue;
        }
        if (chunk.modules[RESOLVED_SSR_VIRTUAL_MODULE_ID]) {
          internals.ssrEntryChunk = chunk;
<<<<<<< HEAD
          delete bundle[chunkName];
=======
>>>>>>> 08f40ceb (Initial)
        }
      }
    }
  };
}
function pluginSSR(options, internals) {
<<<<<<< HEAD
  const ssr = isServerLikeOutput(options.settings.config);
  return {
    build: "ssr",
    hooks: {
      "build:before": () => {
        let vitePlugin = ssr && !options.settings.config.build.split ? vitePluginSSR(internals, options.settings.adapter, options) : void 0;
=======
  const ssr = options.settings.buildOutput === "server";
  return {
    targets: ["server"],
    hooks: {
      "build:before": () => {
        const adapter = options.settings.adapter;
        const ssrPlugin = ssr && vitePluginSSR(internals, adapter, options);
        const vitePlugin = [vitePluginAdapter(adapter)];
        if (ssrPlugin) {
          vitePlugin.unshift(ssrPlugin);
        }
>>>>>>> 08f40ceb (Initial)
        return {
          enforce: "after-user-plugins",
          vitePlugin
        };
      },
<<<<<<< HEAD
      "build:post": async ({ mutate }) => {
        if (!ssr) {
          return;
        }
        if (options.settings.config.build.split) {
          return;
        }
=======
      "build:post": async () => {
        if (!ssr) {
          return;
        }
>>>>>>> 08f40ceb (Initial)
        if (!internals.ssrEntryChunk) {
          throw new Error(`Did not generate an entry chunk for SSR`);
        }
        internals.ssrEntryChunk.fileName = options.settings.config.build.serverEntry;
<<<<<<< HEAD
        const manifest = await createManifest(options, internals);
        await runHookBuildSsr({
          config: options.settings.config,
          manifest,
          logging: options.logging,
          entryPoints: internals.entryPoints,
          middlewareEntryPoint: internals.middlewareEntryPoint
        });
        const code = injectManifest(manifest, internals.ssrEntryChunk);
        mutate(internals.ssrEntryChunk, "server", code);
=======
>>>>>>> 08f40ceb (Initial)
      }
    }
  };
}
<<<<<<< HEAD
const SPLIT_MODULE_ID = "@astro-page-split:";
const RESOLVED_SPLIT_MODULE_ID = "\0@astro-page-split:";
function vitePluginSSRSplit(internals, adapter, options) {
  return {
    name: "@astrojs/vite-plugin-astro-ssr-split",
    enforce: "post",
    options(opts) {
      if (options.settings.config.build.split) {
        const inputs = /* @__PURE__ */ new Set();
        for (const path of Object.keys(options.allPages)) {
          inputs.add(getVirtualModulePageNameFromPath(SPLIT_MODULE_ID, path));
        }
        return addRollupInput(opts, Array.from(inputs));
      }
    },
    resolveId(id) {
      if (id.startsWith(SPLIT_MODULE_ID)) {
        return "\0" + id;
      }
    },
    async load(id) {
      if (id.startsWith(RESOLVED_SPLIT_MODULE_ID)) {
        const imports = [];
        const contents = [];
        const exports = [];
        const path = getPathFromVirtualModulePageName(RESOLVED_SPLIT_MODULE_ID, id);
        const virtualModuleName = getVirtualModulePageNameFromPath(ASTRO_PAGE_MODULE_ID, path);
        let module = await this.resolve(virtualModuleName);
        if (module) {
          imports.push(`import * as pageModule from "${virtualModuleName}";`);
        }
        const ssrCode = generateSSRCode(options.settings.config, adapter);
        imports.push(...ssrCode.imports);
        contents.push(...ssrCode.contents);
        return `${imports.join("\n")}${contents.join("\n")}${exports.join("\n")}`;
      }
      return void 0;
    },
    async generateBundle(_opts, bundle) {
      for (const [, chunk] of Object.entries(bundle)) {
        if (chunk.type === "asset") {
          internals.staticFiles.add(chunk.fileName);
        }
      }
      for (const [chunkName, chunk] of Object.entries(bundle)) {
        if (chunk.type === "asset") {
          continue;
        }
        let shouldDeleteBundle = false;
        for (const moduleKey of Object.keys(chunk.modules)) {
          if (moduleKey.startsWith(RESOLVED_SPLIT_MODULE_ID)) {
            internals.ssrSplitEntryChunks.set(moduleKey, chunk);
            storeEntryPoint(moduleKey, options, internals, chunk.fileName);
            shouldDeleteBundle = true;
          }
        }
        if (shouldDeleteBundle) {
          delete bundle[chunkName];
        }
      }
    }
  };
}
function pluginSSRSplit(options, internals) {
  const ssr = isServerLikeOutput(options.settings.config);
  return {
    build: "ssr",
    hooks: {
      "build:before": () => {
        let vitePlugin = ssr && options.settings.config.build.split ? vitePluginSSRSplit(internals, options.settings.adapter, options) : void 0;
        return {
          enforce: "after-user-plugins",
          vitePlugin
        };
      },
      "build:post": async ({ mutate }) => {
        if (!ssr) {
          return;
        }
        if (!options.settings.config.build.split) {
          return;
        }
        if (internals.ssrSplitEntryChunks.size === 0) {
          throw new Error(`Did not generate an entry chunk for SSR serverless`);
        }
        const manifest = await createManifest(options, internals);
        await runHookBuildSsr({
          config: options.settings.config,
          manifest,
          logging: options.logging,
          entryPoints: internals.entryPoints,
          middlewareEntryPoint: internals.middlewareEntryPoint
        });
        for (const [, chunk] of internals.ssrSplitEntryChunks) {
          const code = injectManifest(manifest, chunk);
          mutate(chunk, "server", code);
        }
      }
    }
  };
}
function generateSSRCode(config, adapter) {
  const imports = [];
  const contents = [];
  let pageMap;
  if (config.build.split) {
    pageMap = "pageModule";
  } else {
    pageMap = "pageMap";
  }
  contents.push(`import * as adapter from '${adapter.serverEntrypoint}';
import { renderers } from '${RENDERERS_MODULE_ID}'; 
import { deserializeManifest as _deserializeManifest } from 'astro/app';
import { _privateSetManifestDontUseThis } from 'astro:ssr-manifest';
const _manifest = Object.assign(_deserializeManifest('${manifestReplace}'), {
	${pageMap},
	renderers,
});
_privateSetManifestDontUseThis(_manifest);
const _args = ${adapter.args ? JSON.stringify(adapter.args) : "undefined"};

${adapter.exports ? `const _exports = adapter.createExports(_manifest, _args);
${adapter.exports.map((name) => {
    if (name === "default") {
      return `const _default = _exports['default'];
export { _default as default };`;
    } else {
      return `export const ${name} = _exports['${name}'];`;
    }
  }).join("\n")}
` : ""}
const _start = 'start';
if(_start in adapter) {
	adapter[_start](_manifest, _args);
}`);
=======
function generateSSRCode(adapter, middlewareId) {
  const edgeMiddleware = adapter?.adapterFeatures?.edgeMiddleware ?? false;
  const imports = [
    `import { renderers } from '${RENDERERS_MODULE_ID}';`,
    `import * as serverEntrypointModule from '${ADAPTER_VIRTUAL_MODULE_ID}';`,
    `import { manifest as defaultManifest } from '${SSR_MANIFEST_VIRTUAL_MODULE_ID}';`,
    `import { serverIslandMap } from '${VIRTUAL_ISLAND_MAP_ID}';`
  ];
  const contents = [
    edgeMiddleware ? `const middleware = (_, next) => next()` : "",
    `const _manifest = Object.assign(defaultManifest, {`,
    `    pageMap,`,
    `    serverIslandMap,`,
    `    renderers,`,
    `    actions: () => import("${ASTRO_ACTIONS_INTERNAL_MODULE_ID}"),`,
    `    middleware: ${edgeMiddleware ? "undefined" : `() => import("${middlewareId}")`}`,
    `});`,
    `const _args = ${adapter.args ? JSON.stringify(adapter.args, null, 4) : "undefined"};`,
    adapter.exports ? `const _exports = serverEntrypointModule.createExports(_manifest, _args);` : "",
    ...adapter.exports?.map((name) => {
      if (name === "default") {
        return `export default _exports.default;`;
      } else {
        return `export const ${name} = _exports['${name}'];`;
      }
    }) ?? [],
    // NOTE: This is intentionally obfuscated!
    // Do NOT simplify this to something like `serverEntrypointModule.start?.(_manifest, _args)`
    // They are NOT equivalent! Some bundlers will throw if `start` is not exported, but we
    // only want to silently ignore it... hence the dynamic, obfuscated weirdness.
    `const _start = 'start';
if (_start in serverEntrypointModule) {
	serverEntrypointModule[_start](_manifest, _args);
}`
  ];
>>>>>>> 08f40ceb (Initial)
  return {
    imports,
    contents
  };
}
<<<<<<< HEAD
function injectManifest(manifest, chunk) {
  const code = chunk.code;
  return code.replace(replaceExp, () => {
    return JSON.stringify(manifest);
  });
}
async function createManifest(buildOpts, internals) {
  if (buildOpts.settings.config.build.split) {
    if (internals.ssrSplitEntryChunks.size === 0) {
      throw new Error(`Did not generate an entry chunk for SSR in serverless mode`);
    }
  } else {
    if (!internals.ssrEntryChunk) {
      throw new Error(`Did not generate an entry chunk for SSR`);
    }
  }
  const clientStatics = new Set(
    await glob("**/*", {
      cwd: fileURLToPath(buildOpts.settings.config.build.client)
    })
  );
  for (const file of clientStatics) {
    internals.staticFiles.add(file);
  }
  const staticFiles = internals.staticFiles;
  return buildManifest(buildOpts, internals, Array.from(staticFiles));
}
function storeEntryPoint(moduleKey, options, internals, fileName) {
  const componentPath = getPathFromVirtualModulePageName(RESOLVED_SPLIT_MODULE_ID, moduleKey);
  for (const [page, pageData] of Object.entries(options.allPages)) {
    if (componentPath == page) {
      const publicPath = fileURLToPath(options.settings.config.build.server);
      internals.entryPoints.set(pageData.route, pathToFileURL(join(publicPath, fileName)));
    }
  }
}
function buildManifest(opts, internals, staticFiles) {
  const { settings } = opts;
  const routes = [];
  const entryModules = Object.fromEntries(internals.entrySpecifierToBundleMap.entries());
  if (settings.scripts.some((script) => script.stage === "page")) {
    staticFiles.push(entryModules[PAGE_SCRIPT_ID]);
  }
  const prefixAssetPath = (pth) => {
    if (settings.config.build.assetsPrefix) {
      return joinPaths(settings.config.build.assetsPrefix, pth);
    } else {
      return prependForwardSlash(joinPaths(settings.config.base, pth));
    }
  };
  for (const route of opts.manifest.routes) {
    if (!route.prerender)
      continue;
    if (!route.pathname)
      continue;
    const outFolder = getOutFolder(opts.settings.config, route.pathname, route.type);
    const outFile = getOutFile(opts.settings.config, outFolder, route.pathname, route.type);
    const file = outFile.toString().replace(opts.settings.config.build.client.toString(), "");
    routes.push({
      file,
      links: [],
      scripts: [],
      styles: [],
      routeData: serializeRouteData(route, settings.config.trailingSlash)
    });
    staticFiles.push(file);
  }
  for (const route of opts.manifest.routes) {
    const pageData = internals.pagesByComponent.get(route.component);
    if (route.prerender || !pageData)
      continue;
    const scripts = [];
    if (pageData.hoistedScript) {
      const hoistedValue = pageData.hoistedScript.value;
      const value = hoistedValue.endsWith(".js") ? prefixAssetPath(hoistedValue) : hoistedValue;
      scripts.unshift(
        Object.assign({}, pageData.hoistedScript, {
          value
        })
      );
    }
    if (settings.scripts.some((script) => script.stage === "page")) {
      const src = entryModules[PAGE_SCRIPT_ID];
      scripts.push({
        type: "external",
        value: prefixAssetPath(src)
      });
    }
    const links = [];
    const styles = pageData.styles.sort(cssOrder).map(({ sheet }) => sheet).map((s) => s.type === "external" ? { ...s, src: prefixAssetPath(s.src) } : s).reduce(mergeInlineCss, []);
    routes.push({
      file: "",
      links,
      scripts: [
        ...scripts,
        ...settings.scripts.filter((script) => script.stage === "head-inline").map(({ stage, content }) => ({ stage, children: content }))
      ],
      styles,
      routeData: serializeRouteData(route, settings.config.trailingSlash)
    });
  }
  if (!(BEFORE_HYDRATION_SCRIPT_ID in entryModules)) {
    entryModules[BEFORE_HYDRATION_SCRIPT_ID] = "";
  }
  const ssrManifest = {
    adapterName: opts.settings.adapter.name,
    routes,
    site: settings.config.site,
    base: settings.config.base,
    compressHTML: settings.config.compressHTML,
    assetsPrefix: settings.config.build.assetsPrefix,
    markdown: settings.config.markdown,
    componentMetadata: Array.from(internals.componentMetadata),
    renderers: [],
    clientDirectives: Array.from(settings.clientDirectives),
    entryModules,
    assets: staticFiles.map(prefixAssetPath)
  };
  return ssrManifest;
}
export {
  RESOLVED_SPLIT_MODULE_ID,
  SPLIT_MODULE_ID,
  SSR_VIRTUAL_MODULE_ID,
  createManifest,
  injectManifest,
  pluginSSR,
  pluginSSRSplit
=======
export {
  RESOLVED_SSR_VIRTUAL_MODULE_ID,
  pluginSSR
>>>>>>> 08f40ceb (Initial)
};
