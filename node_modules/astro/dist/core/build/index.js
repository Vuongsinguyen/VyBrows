<<<<<<< HEAD
import * as colors from "kleur/colors";
import fs from "node:fs";
import { performance } from "node:perf_hooks";
import { fileURLToPath } from "node:url";
import { injectImageEndpoint } from "../../assets/internal.js";
=======
import fs from "node:fs";
import { performance } from "node:perf_hooks";
import { fileURLToPath } from "node:url";
import { blue, bold, green } from "kleur/colors";
>>>>>>> 08f40ceb (Initial)
import { telemetry } from "../../events/index.js";
import { eventCliSession } from "../../events/session.js";
import {
  runHookBuildDone,
  runHookBuildStart,
  runHookConfigDone,
  runHookConfigSetup
<<<<<<< HEAD
} from "../../integrations/index.js";
import { isServerLikeOutput } from "../../prerender/utils.js";
import { resolveConfig } from "../config/config.js";
import { createNodeLogging } from "../config/logging.js";
import { createSettings } from "../config/settings.js";
import { createVite } from "../create-vite.js";
import { debug, info, levels, timerMessage, warn } from "../logger/core.js";
import { apply as applyPolyfill } from "../polyfill.js";
import { RouteCache } from "../render/route-cache.js";
import { createRouteManifest } from "../routing/index.js";
import { collectPagesData } from "./page-data.js";
import { staticBuild, viteBuild } from "./static-build.js";
import { getTimeStat } from "./util.js";
async function build(inlineConfig, options) {
  applyPolyfill();
  const logging = createNodeLogging(inlineConfig);
  const { userConfig, astroConfig } = await resolveConfig(inlineConfig, "build");
  telemetry.record(eventCliSession("build", userConfig));
  const settings = createSettings(astroConfig, fileURLToPath(astroConfig.root));
  const builder = new AstroBuilder(settings, {
    ...options,
    logging,
    mode: inlineConfig.mode
=======
} from "../../integrations/hooks.js";
import { createDevelopmentManifest } from "../../vite-plugin-astro-server/plugin.js";
import { resolveConfig } from "../config/config.js";
import { createNodeLogger } from "../config/logging.js";
import { createSettings } from "../config/settings.js";
import { createVite } from "../create-vite.js";
import { createKey, getEnvironmentKey, hasEnvironmentKey } from "../encryption.js";
import { AstroError, AstroErrorData } from "../errors/index.js";
import { levels, timerMessage } from "../logger/core.js";
import { apply as applyPolyfill } from "../polyfill.js";
import { createRoutesList } from "../routing/index.js";
import { getServerIslandRouteData } from "../server-islands/endpoint.js";
import { clearContentLayerCache } from "../sync/index.js";
import { ensureProcessNodeEnv } from "../util.js";
import { collectPagesData } from "./page-data.js";
import { staticBuild, viteBuild } from "./static-build.js";
import { getTimeStat } from "./util.js";
async function build(inlineConfig, options = {}) {
  ensureProcessNodeEnv(options.devOutput ? "development" : "production");
  applyPolyfill();
  const logger = createNodeLogger(inlineConfig);
  const { userConfig, astroConfig } = await resolveConfig(inlineConfig, "build");
  telemetry.record(eventCliSession("build", userConfig));
  const settings = await createSettings(astroConfig, fileURLToPath(astroConfig.root));
  if (inlineConfig.force) {
    await clearContentLayerCache({ settings, logger, fs, isDev: false });
  }
  const builder = new AstroBuilder(settings, {
    ...options,
    logger,
    mode: inlineConfig.mode ?? "production",
    runtimeMode: options.devOutput ? "development" : "production"
>>>>>>> 08f40ceb (Initial)
  });
  await builder.run();
}
class AstroBuilder {
<<<<<<< HEAD
  constructor(settings, options) {
    this.mode = "production";
    if (options.mode) {
      this.mode = options.mode;
    }
    this.settings = settings;
    this.logging = options.logging;
    this.teardownCompiler = options.teardownCompiler ?? false;
    this.routeCache = new RouteCache(this.logging);
    this.origin = settings.config.site ? new URL(settings.config.site).origin : `http://localhost:${settings.config.server.port}`;
    this.manifest = { routes: [] };
=======
  settings;
  logger;
  mode;
  runtimeMode;
  origin;
  routesList;
  timer;
  teardownCompiler;
  constructor(settings, options) {
    this.mode = options.mode;
    this.runtimeMode = options.runtimeMode;
    this.settings = settings;
    this.logger = options.logger;
    this.teardownCompiler = options.teardownCompiler ?? true;
    this.origin = settings.config.site ? new URL(settings.config.site).origin : `http://localhost:${settings.config.server.port}`;
    this.routesList = { routes: [] };
>>>>>>> 08f40ceb (Initial)
    this.timer = {};
  }
  /** Setup Vite and run any async setup logic that couldn't run inside of the constructor. */
  async setup() {
<<<<<<< HEAD
    debug("build", "Initial setup...");
    const { logging } = this;
=======
    this.logger.debug("build", "Initial setup...");
    const { logger } = this;
>>>>>>> 08f40ceb (Initial)
    this.timer.init = performance.now();
    this.settings = await runHookConfigSetup({
      settings: this.settings,
      command: "build",
<<<<<<< HEAD
      logging
    });
    if (this.settings.config.experimental.assets && isServerLikeOutput(this.settings.config)) {
      this.settings = injectImageEndpoint(this.settings);
    }
    this.manifest = createRouteManifest({ settings: this.settings }, this.logging);
    const viteConfig = await createVite(
      {
        mode: this.mode,
=======
      logger
    });
    const manifest = createDevelopmentManifest(this.settings);
    this.routesList = await createRoutesList({ settings: this.settings }, this.logger);
    await runHookConfigDone({ settings: this.settings, logger, command: "build" });
    if (!this.settings.config.adapter && this.settings.buildOutput === "server") {
      throw new AstroError(AstroErrorData.NoAdapterInstalled);
    }
    const viteConfig = await createVite(
      {
>>>>>>> 08f40ceb (Initial)
        server: {
          hmr: false,
          middlewareMode: true
        }
      },
<<<<<<< HEAD
      { settings: this.settings, logging, mode: "build", command: "build" }
    );
    await runHookConfigDone({ settings: this.settings, logging });
    const { syncInternal } = await import("../sync/index.js");
    const syncRet = await syncInternal(this.settings, { logging, fs });
    if (syncRet !== 0) {
      return process.exit(syncRet);
    }
=======
      {
        settings: this.settings,
        logger: this.logger,
        mode: this.mode,
        command: "build",
        sync: false,
        routesList: this.routesList,
        manifest
      }
    );
    const { syncInternal } = await import("../sync/index.js");
    await syncInternal({
      mode: this.mode,
      settings: this.settings,
      logger,
      fs,
      routesList: this.routesList,
      command: "build",
      manifest
    });
>>>>>>> 08f40ceb (Initial)
    return { viteConfig };
  }
  /** Run the build logic. build() is marked private because usage should go through ".run()" */
  async build({ viteConfig }) {
<<<<<<< HEAD
    await runHookBuildStart({ config: this.settings.config, logging: this.logging });
    this.validateConfig();
    info(this.logging, "build", `output target: ${colors.green(this.settings.config.output)}`);
    if (this.settings.adapter) {
      info(this.logging, "build", `deploy adapter: ${colors.green(this.settings.adapter.name)}`);
    }
    info(this.logging, "build", "Collecting build info...");
    this.timer.loadStart = performance.now();
    const { assets, allPages } = await collectPagesData({
      settings: this.settings,
      logging: this.logging,
      manifest: this.manifest
    });
    debug("build", timerMessage("All pages loaded", this.timer.loadStart));
    const pageNames = [];
    this.timer.buildStart = performance.now();
    info(
      this.logging,
      "build",
      colors.dim(`Completed in ${getTimeStat(this.timer.init, performance.now())}.`)
    );
    const opts = {
      allPages,
      settings: this.settings,
      logging: this.logging,
      manifest: this.manifest,
      mode: this.mode,
      origin: this.origin,
      pageNames,
      routeCache: this.routeCache,
      teardownCompiler: this.teardownCompiler,
      viteConfig
    };
    const { internals } = await viteBuild(opts);
    await staticBuild(opts, internals);
    this.timer.assetsStart = performance.now();
    Object.keys(assets).map((k) => {
      if (!assets[k])
        return;
=======
    await runHookBuildStart({ config: this.settings.config, logger: this.logger });
    this.validateConfig();
    this.logger.info("build", `output: ${blue('"' + this.settings.config.output + '"')}`);
    this.logger.info("build", `mode: ${blue('"' + this.settings.buildOutput + '"')}`);
    this.logger.info("build", `directory: ${blue(fileURLToPath(this.settings.config.outDir))}`);
    if (this.settings.adapter) {
      this.logger.info("build", `adapter: ${green(this.settings.adapter.name)}`);
    }
    this.logger.info("build", "Collecting build info...");
    this.timer.loadStart = performance.now();
    const { assets, allPages } = collectPagesData({
      settings: this.settings,
      logger: this.logger,
      manifest: this.routesList
    });
    this.logger.debug("build", timerMessage("All pages loaded", this.timer.loadStart));
    const pageNames = [];
    this.timer.buildStart = performance.now();
    this.logger.info(
      "build",
      green(`\u2713 Completed in ${getTimeStat(this.timer.init, performance.now())}.`)
    );
    const hasKey = hasEnvironmentKey();
    const keyPromise = hasKey ? getEnvironmentKey() : createKey();
    const opts = {
      allPages,
      settings: this.settings,
      logger: this.logger,
      routesList: this.routesList,
      runtimeMode: this.runtimeMode,
      origin: this.origin,
      pageNames,
      teardownCompiler: this.teardownCompiler,
      viteConfig,
      key: keyPromise
    };
    const { internals, ssrOutputChunkNames } = await viteBuild(opts);
    const hasServerIslands = this.settings.serverIslandNameMap.size > 0;
    if (hasServerIslands && this.settings.buildOutput !== "server") {
      throw new AstroError(AstroErrorData.NoAdapterInstalledServerIslands);
    }
    await staticBuild(opts, internals, ssrOutputChunkNames);
    this.timer.assetsStart = performance.now();
    Object.keys(assets).map((k) => {
      if (!assets[k]) return;
>>>>>>> 08f40ceb (Initial)
      const filePath = new URL(`file://${k}`);
      fs.mkdirSync(new URL("./", filePath), { recursive: true });
      fs.writeFileSync(filePath, assets[k], "utf8");
      delete assets[k];
    });
<<<<<<< HEAD
    debug("build", timerMessage("Additional assets copied", this.timer.assetsStart));
    await runHookBuildDone({
      config: this.settings.config,
      pages: pageNames,
      routes: Object.values(allPages).map((pd) => pd.route),
      logging: this.logging
    });
    if (this.logging.level && levels[this.logging.level] <= levels["info"]) {
      await this.printStats({
        logging: this.logging,
        timeStart: this.timer.init,
        pageCount: pageNames.length,
        buildMode: this.settings.config.output
      });
    }
    this.settings.timer.writeStats();
  }
  /** Build the given Astro project.  */
  async run() {
=======
    this.logger.debug("build", timerMessage("Additional assets copied", this.timer.assetsStart));
    await runHookBuildDone({
      settings: this.settings,
      pages: pageNames,
      routes: Object.values(allPages).flat().map((pageData) => pageData.route).concat(hasServerIslands ? getServerIslandRouteData(this.settings.config) : []),
      logger: this.logger
    });
    if (this.logger.level && levels[this.logger.level()] <= levels["info"]) {
      await this.printStats({
        logger: this.logger,
        timeStart: this.timer.init,
        pageCount: pageNames.length,
        buildMode: this.settings.buildOutput
        // buildOutput is always set at this point
      });
    }
  }
  /** Build the given Astro project.  */
  async run() {
    this.settings.timer.start("Total build");
>>>>>>> 08f40ceb (Initial)
    const setupData = await this.setup();
    try {
      await this.build(setupData);
    } catch (_err) {
      throw _err;
<<<<<<< HEAD
=======
    } finally {
      this.settings.timer.end("Total build");
      this.settings.timer.writeStats();
>>>>>>> 08f40ceb (Initial)
    }
  }
  validateConfig() {
    const { config } = this.settings;
    if (config.outDir.toString() === config.root.toString()) {
      throw new Error(
        `the outDir cannot be the root folder. Please build to a folder such as dist.`
      );
    }
<<<<<<< HEAD
    if (config.build.split === true) {
      if (config.output === "static") {
        warn(
          this.logging,
          "configuration",
          'The option `build.split` won\'t take effect, because `output` is not `"server"` or `"hybrid"`.'
        );
      }
    }
    if (config.build.excludeMiddleware === true) {
      if (config.output === "static") {
        warn(
          this.logging,
          "configuration",
          'The option `build.excludeMiddleware` won\'t take effect, because `output` is not `"server"` or `"hybrid"`.'
        );
      }
    }
    if (config.build.split === true) {
      if (config.output !== "server") {
        throw new Error(
          'The option `build.split` can only be used when `output` is set to `"server"`.'
        );
      }
    }
  }
  /** Stats */
  async printStats({
    logging,
=======
  }
  /** Stats */
  async printStats({
    logger,
>>>>>>> 08f40ceb (Initial)
    timeStart,
    pageCount,
    buildMode
  }) {
    const total = getTimeStat(timeStart, performance.now());
    let messages = [];
    if (buildMode === "static") {
<<<<<<< HEAD
      messages = [`${pageCount} page(s) built in`, colors.bold(total)];
    } else {
      messages = ["Server built in", colors.bold(total)];
    }
    info(logging, "build", messages.join(" "));
    info(logging, "build", `${colors.bold("Complete!")}`);
=======
      messages = [`${pageCount} page(s) built in`, bold(total)];
    } else {
      messages = ["Server built in", bold(total)];
    }
    logger.info("build", messages.join(" "));
    logger.info("build", `${bold("Complete!")}`);
>>>>>>> 08f40ceb (Initial)
  }
}
export {
  build as default
};
