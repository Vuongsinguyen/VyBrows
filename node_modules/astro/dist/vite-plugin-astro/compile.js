import { transformWithEsbuild } from "vite";
<<<<<<< HEAD
import { cachedCompilation } from "../core/compile/index.js";
import { getFileInfo } from "../vite-plugin-utils/index.js";
const FRONTMATTER_PARSE_REGEXP = /^\-\-\-(.*)^\-\-\-/ms;
async function cachedFullCompilation({
  compileProps,
  logging
=======
import { compile } from "../core/compile/index.js";
import { getFileInfo } from "../vite-plugin-utils/index.js";
import { frontmatterRE } from "./utils.js";
async function compileAstro({
  compileProps,
  astroFileToCompileMetadata,
  logger
>>>>>>> 08f40ceb (Initial)
}) {
  let transformResult;
  let esbuildResult;
  try {
<<<<<<< HEAD
    transformResult = await cachedCompilation(compileProps);
    esbuildResult = await transformWithEsbuild(transformResult.code, compileProps.filename, {
      loader: "ts",
      target: "esnext",
=======
    transformResult = await compile(compileProps);
    esbuildResult = await transformWithEsbuild(transformResult.code, compileProps.filename, {
      ...compileProps.viteConfig.esbuild,
      loader: "ts",
>>>>>>> 08f40ceb (Initial)
      sourcemap: "external",
      tsconfigRaw: {
        compilerOptions: {
          // Ensure client:only imports are treeshaken
          verbatimModuleSyntax: false,
          importsNotUsedAsValues: "remove"
        }
      }
    });
  } catch (err) {
    await enhanceCompileError({
      err,
      id: compileProps.filename,
      source: compileProps.source,
      config: compileProps.astroConfig,
<<<<<<< HEAD
      logging
=======
      logger
>>>>>>> 08f40ceb (Initial)
    });
    throw err;
  }
  const { fileId: file, fileUrl: url } = getFileInfo(
    compileProps.filename,
    compileProps.astroConfig
  );
  let SUFFIX = "";
  SUFFIX += `
const $$file = ${JSON.stringify(file)};
const $$url = ${JSON.stringify(
    url
  )};export { $$file as file, $$url as url };
`;
  if (!compileProps.viteConfig.isProduction) {
    let i = 0;
    while (i < transformResult.scripts.length) {
      SUFFIX += `import "${compileProps.filename}?astro&type=script&index=${i}&lang.ts";`;
      i++;
    }
  }
<<<<<<< HEAD
  if (!compileProps.viteConfig.isProduction) {
    SUFFIX += `
if (import.meta.hot) { import.meta.hot.decline() }`;
  }
=======
  astroFileToCompileMetadata.set(compileProps.filename, {
    originalCode: compileProps.source,
    css: transformResult.css,
    scripts: transformResult.scripts
  });
>>>>>>> 08f40ceb (Initial)
  return {
    ...transformResult,
    code: esbuildResult.code + SUFFIX,
    map: esbuildResult.map
  };
}
async function enhanceCompileError({
  err,
  id,
  source
}) {
<<<<<<< HEAD
  var _a;
  const lineText = (_a = err.loc) == null ? void 0 : _a.lineText;
  const scannedFrontmatter = FRONTMATTER_PARSE_REGEXP.exec(source);
  if (scannedFrontmatter) {
    const frontmatter = scannedFrontmatter[1].replace(/\breturn\b/g, "throw");
    if (lineText && !frontmatter.includes(lineText))
      throw err;
=======
  const lineText = err.loc?.lineText;
  const scannedFrontmatter = frontmatterRE.exec(source);
  if (scannedFrontmatter) {
    const frontmatter = scannedFrontmatter[1].replace(/\breturn\b/g, "throw");
    if (lineText && !frontmatter.includes(lineText)) throw err;
>>>>>>> 08f40ceb (Initial)
    try {
      await transformWithEsbuild(frontmatter, id, {
        loader: "ts",
        target: "esnext",
        sourcemap: false
      });
    } catch (frontmatterErr) {
<<<<<<< HEAD
      if (frontmatterErr == null ? void 0 : frontmatterErr.message) {
=======
      if (frontmatterErr?.message) {
>>>>>>> 08f40ceb (Initial)
        frontmatterErr.message = frontmatterErr.message.replace(
          "end of file",
          "end of frontmatter"
        );
      }
      throw frontmatterErr;
    }
  }
  throw err;
}
export {
<<<<<<< HEAD
  cachedFullCompilation
=======
  compileAstro
>>>>>>> 08f40ceb (Initial)
};
