<<<<<<< HEAD
import glob from "fast-glob";
import { cyan } from "kleur/colors";
import * as path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { normalizePath } from "vite";
import { AstroError } from "../core/errors/errors.js";
import { AstroErrorData } from "../core/errors/index.js";
import { info, warn } from "../core/logger/core.js";
import { isRelativePath } from "../core/path.js";
import { CONTENT_TYPES_FILE, VIRTUAL_MODULE_ID } from "./consts.js";
=======
import * as path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { bold, cyan } from "kleur/colors";
import { glob } from "tinyglobby";
import { normalizePath } from "vite";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import { AstroError } from "../core/errors/errors.js";
import { AstroErrorData, AstroUserError } from "../core/errors/index.js";
import { isRelativePath } from "../core/path.js";
import {
  COLLECTIONS_DIR,
  CONTENT_LAYER_TYPE,
  CONTENT_TYPES_FILE,
  LIVE_CONTENT_TYPE,
  VIRTUAL_MODULE_ID
} from "./consts.js";
>>>>>>> 08f40ceb (Initial)
import {
  getContentEntryIdAndSlug,
  getContentPaths,
  getDataEntryExts,
  getDataEntryId,
  getEntryCollectionName,
  getEntryConfigByExtMap,
  getEntrySlug,
  getEntryType,
  reloadContentConfigObserver
} from "./utils.js";
<<<<<<< HEAD
class UnsupportedFileTypeError extends Error {
}
async function createContentTypesGenerator({
  contentConfigObserver,
  fs,
  logging,
=======
async function createContentTypesGenerator({
  contentConfigObserver,
  fs,
  logger,
>>>>>>> 08f40ceb (Initial)
  settings,
  viteServer
}) {
  const collectionEntryMap = {};
  const contentPaths = getContentPaths(settings.config, fs);
  const contentEntryConfigByExt = getEntryConfigByExtMap(settings.contentEntryTypes);
  const contentEntryExts = [...contentEntryConfigByExt.keys()];
  const dataEntryExts = getDataEntryExts(settings);
  let events = [];
  let debounceTimeout;
  const typeTemplateContent = await fs.promises.readFile(contentPaths.typesTemplate, "utf-8");
  async function init() {
<<<<<<< HEAD
    if (!fs.existsSync(contentPaths.contentDir)) {
      return { typesGenerated: false, reason: "no-content-dir" };
    }
    events.push({
      type: { name: "add", entry: contentPaths.config.url },
      opts: { logLevel: "warn" }
    });
    const globResult = await glob("**", {
      cwd: fileURLToPath(contentPaths.contentDir),
      fs: {
        readdir: fs.readdir.bind(fs),
        readdirSync: fs.readdirSync.bind(fs)
      },
      onlyFiles: false,
      objectMode: true
    });
    for (const entry of globResult) {
      const entryURL = new URL(entry.path, contentPaths.contentDir);
      if (entryURL.href.startsWith(contentPaths.config.url.href))
        continue;
      if (entry.dirent.isFile()) {
        events.push({
          type: { name: "add", entry: entryURL },
          opts: { logLevel: "warn" }
        });
      } else if (entry.dirent.isDirectory()) {
        events.push({ type: { name: "addDir", entry: entryURL }, opts: { logLevel: "warn" } });
=======
    events.push({ name: "add", entry: contentPaths.config.url });
    if (settings.config.legacy.collections) {
      if (!fs.existsSync(contentPaths.contentDir)) {
        return { typesGenerated: false, reason: "no-content-dir" };
      }
      const globResult = await glob("**", {
        cwd: fileURLToPath(contentPaths.contentDir),
        absolute: true
      });
      for (const fullPath of globResult) {
        const entryURL = pathToFileURL(fullPath);
        if (entryURL.href.startsWith(contentPaths.config.url.href)) continue;
        const stat = fs.statSync(fullPath);
        if (stat.isFile()) {
          events.push({ name: "add", entry: entryURL });
        } else if (stat.isDirectory()) {
          events.push({ name: "addDir", entry: entryURL });
        }
>>>>>>> 08f40ceb (Initial)
      }
    }
    await runEvents();
    return { typesGenerated: true };
  }
<<<<<<< HEAD
  async function handleEvent(event, opts) {
    const logLevel = (opts == null ? void 0 : opts.logLevel) ?? "info";
=======
  async function handleEvent(event) {
>>>>>>> 08f40ceb (Initial)
    if (event.name === "addDir" || event.name === "unlinkDir") {
      const collection2 = normalizePath(
        path.relative(fileURLToPath(contentPaths.contentDir), fileURLToPath(event.entry))
      );
      const collectionKey2 = JSON.stringify(collection2);
      const isCollectionEvent = collection2.split("/").length === 1;
<<<<<<< HEAD
      if (!isCollectionEvent)
        return { shouldGenerateTypes: false };
      switch (event.name) {
        case "addDir":
          collectionEntryMap[JSON.stringify(collection2)] = { type: "unknown", entries: {} };
          if (logLevel === "info") {
            info(logging, "content", `${cyan(collection2)} collection added`);
          }
          break;
        case "unlinkDir":
          if (collectionKey2 in collectionEntryMap) {
            delete collectionEntryMap[JSON.stringify(collection2)];
          }
=======
      if (!isCollectionEvent) return { shouldGenerateTypes: false };
      switch (event.name) {
        case "addDir":
          collectionEntryMap[collectionKey2] = {
            type: "unknown",
            entries: {}
          };
          logger.debug("content", `${cyan(collection2)} collection added`);
          break;
        case "unlinkDir":
          delete collectionEntryMap[collectionKey2];
>>>>>>> 08f40ceb (Initial)
          break;
      }
      return { shouldGenerateTypes: true };
    }
    const fileType = getEntryType(
      fileURLToPath(event.entry),
      contentPaths,
      contentEntryExts,
<<<<<<< HEAD
      dataEntryExts,
      settings.config.experimental.assets
=======
      dataEntryExts
>>>>>>> 08f40ceb (Initial)
    );
    if (fileType === "ignored") {
      return { shouldGenerateTypes: false };
    }
    if (fileType === "config") {
      await reloadContentConfigObserver({ fs, settings, viteServer });
      return { shouldGenerateTypes: true };
    }
<<<<<<< HEAD
    if (fileType === "unsupported") {
      if (event.name === "unlink") {
        return { shouldGenerateTypes: false };
      }
      const { id: id2 } = getContentEntryIdAndSlug({
        entry: event.entry,
        contentDir: contentPaths.contentDir,
        collection: ""
      });
      return {
        shouldGenerateTypes: false,
        error: new UnsupportedFileTypeError(id2)
      };
    }
=======
>>>>>>> 08f40ceb (Initial)
    const { entry } = event;
    const { contentDir } = contentPaths;
    const collection = getEntryCollectionName({ entry, contentDir });
    if (collection === void 0) {
<<<<<<< HEAD
      if (["info", "warn"].includes(logLevel)) {
        warn(
          logging,
          "content",
          `${cyan(
            normalizePath(
              path.relative(fileURLToPath(contentPaths.contentDir), fileURLToPath(event.entry))
            )
          )} must be nested in a collection directory. Skipping.`
        );
      }
=======
      logger.warn(
        "content",
        `${bold(
          normalizePath(
            path.relative(fileURLToPath(contentPaths.contentDir), fileURLToPath(event.entry))
          )
        )} must live in a ${bold("content/...")} collection subdirectory.`
      );
>>>>>>> 08f40ceb (Initial)
      return { shouldGenerateTypes: false };
    }
    if (fileType === "data") {
      const id2 = getDataEntryId({ entry, contentDir, collection });
      const collectionKey2 = JSON.stringify(collection);
      const entryKey2 = JSON.stringify(id2);
      switch (event.name) {
        case "add":
          if (!(collectionKey2 in collectionEntryMap)) {
            collectionEntryMap[collectionKey2] = { type: "data", entries: {} };
          }
          const collectionInfo2 = collectionEntryMap[collectionKey2];
          if (collectionInfo2.type === "content") {
<<<<<<< HEAD
            viteServer.ws.send({
=======
            viteServer.hot.send({
>>>>>>> 08f40ceb (Initial)
              type: "error",
              err: new AstroError({
                ...AstroErrorData.MixedContentDataCollectionError,
                message: AstroErrorData.MixedContentDataCollectionError.message(collectionKey2),
                location: { file: entry.pathname }
              })
            });
            return { shouldGenerateTypes: false };
          }
          if (!(entryKey2 in collectionEntryMap[collectionKey2])) {
            collectionEntryMap[collectionKey2] = {
              type: "data",
              entries: { ...collectionInfo2.entries, [entryKey2]: {} }
            };
          }
          return { shouldGenerateTypes: true };
        case "unlink":
          if (collectionKey2 in collectionEntryMap && entryKey2 in collectionEntryMap[collectionKey2].entries) {
            delete collectionEntryMap[collectionKey2].entries[entryKey2];
          }
          return { shouldGenerateTypes: true };
        case "change":
          return { shouldGenerateTypes: false };
      }
    }
    const contentEntryType = contentEntryConfigByExt.get(path.extname(event.entry.pathname));
<<<<<<< HEAD
    if (!contentEntryType)
      return { shouldGenerateTypes: false };
    const { id, slug: generatedSlug } = getContentEntryIdAndSlug({ entry, contentDir, collection });
=======
    if (!contentEntryType) return { shouldGenerateTypes: false };
    const { id, slug: generatedSlug } = getContentEntryIdAndSlug({
      entry,
      contentDir,
      collection
    });
>>>>>>> 08f40ceb (Initial)
    const collectionKey = JSON.stringify(collection);
    if (!(collectionKey in collectionEntryMap)) {
      collectionEntryMap[collectionKey] = { type: "content", entries: {} };
    }
    const collectionInfo = collectionEntryMap[collectionKey];
    if (collectionInfo.type === "data") {
<<<<<<< HEAD
      viteServer.ws.send({
=======
      viteServer.hot.send({
>>>>>>> 08f40ceb (Initial)
        type: "error",
        err: new AstroError({
          ...AstroErrorData.MixedContentDataCollectionError,
          message: AstroErrorData.MixedContentDataCollectionError.message(collectionKey),
          location: { file: entry.pathname }
        })
      });
      return { shouldGenerateTypes: false };
    }
    const entryKey = JSON.stringify(id);
    switch (event.name) {
      case "add":
        const addedSlug = await getEntrySlug({
          generatedSlug,
          id,
          collection,
          fileUrl: event.entry,
          contentEntryType,
          fs
        });
        if (!(entryKey in collectionEntryMap[collectionKey].entries)) {
          collectionEntryMap[collectionKey] = {
            type: "content",
<<<<<<< HEAD
            entries: { ...collectionInfo.entries, [entryKey]: { slug: addedSlug } }
=======
            entries: {
              ...collectionInfo.entries,
              [entryKey]: { slug: addedSlug }
            }
>>>>>>> 08f40ceb (Initial)
          };
        }
        return { shouldGenerateTypes: true };
      case "unlink":
        if (collectionKey in collectionEntryMap && entryKey in collectionEntryMap[collectionKey].entries) {
          delete collectionEntryMap[collectionKey].entries[entryKey];
        }
        return { shouldGenerateTypes: true };
      case "change":
        const changedSlug = await getEntrySlug({
          generatedSlug,
          id,
          collection,
          fileUrl: event.entry,
          contentEntryType,
          fs
        });
        const entryMetadata = collectionInfo.entries[entryKey];
<<<<<<< HEAD
        if ((entryMetadata == null ? void 0 : entryMetadata.slug) !== changedSlug) {
=======
        if (entryMetadata?.slug !== changedSlug) {
>>>>>>> 08f40ceb (Initial)
          collectionInfo.entries[entryKey].slug = changedSlug;
          return { shouldGenerateTypes: true };
        }
        return { shouldGenerateTypes: false };
    }
  }
<<<<<<< HEAD
  function queueEvent(rawEvent, opts) {
    const event = {
      type: {
        entry: pathToFileURL(rawEvent.entry),
        name: rawEvent.name
      },
      opts
    };
    if (!event.type.entry.pathname.startsWith(contentPaths.contentDir.pathname))
      return;
=======
  function queueEvent(rawEvent) {
    const event = {
      entry: pathToFileURL(rawEvent.entry),
      name: rawEvent.name
    };
    if (settings.config.legacy.collections) {
      if (!event.entry.pathname.startsWith(contentPaths.contentDir.pathname)) {
        return;
      }
    } else if (contentPaths.config.url.pathname !== event.entry.pathname) {
      return;
    }
>>>>>>> 08f40ceb (Initial)
    events.push(event);
    debounceTimeout && clearTimeout(debounceTimeout);
    const runEventsSafe = async () => {
      try {
<<<<<<< HEAD
        await runEvents(opts);
=======
        await runEvents();
>>>>>>> 08f40ceb (Initial)
      } catch {
      }
    };
    debounceTimeout = setTimeout(
      runEventsSafe,
      50
      /* debounce to batch chokidar events */
    );
  }
<<<<<<< HEAD
  async function runEvents(opts) {
    const logLevel = (opts == null ? void 0 : opts.logLevel) ?? "info";
    const eventResponses = [];
    for (const event of events) {
      const response = await handleEvent(event.type, event.opts);
      eventResponses.push(response);
    }
    events = [];
    let unsupportedFiles = [];
    for (const response of eventResponses) {
      if (response.error instanceof UnsupportedFileTypeError) {
        unsupportedFiles.push(response.error.message);
      }
    }
    if (unsupportedFiles.length > 0 && ["info", "warn"].includes(logLevel)) {
      warn(
        logging,
        "content",
        `Unsupported file types found. Prefix with an underscore (\`_\`) to ignore:
- ${unsupportedFiles.join(
          "\n"
        )}`
      );
    }
=======
  async function runEvents() {
    const eventResponses = [];
    for (const event of events) {
      const response = await handleEvent(event);
      eventResponses.push(response);
    }
    events = [];
>>>>>>> 08f40ceb (Initial)
    const observable = contentConfigObserver.get();
    if (eventResponses.some((r) => r.shouldGenerateTypes)) {
      await writeContentFiles({
        fs,
        collectionEntryMap,
        contentPaths,
        typeTemplateContent,
        contentConfig: observable.status === "loaded" ? observable.config : void 0,
        contentEntryTypes: settings.contentEntryTypes,
<<<<<<< HEAD
        viteServer
      });
      invalidateVirtualMod(viteServer);
      if (observable.status === "loaded" && ["info", "warn"].includes(logLevel)) {
        warnNonexistentCollections({
          logging,
          contentConfig: observable.config,
          collectionEntryMap
        });
      }
=======
        viteServer,
        logger,
        settings
      });
      invalidateVirtualMod(viteServer);
>>>>>>> 08f40ceb (Initial)
    }
  }
  return { init, queueEvent };
}
function invalidateVirtualMod(viteServer) {
  const virtualMod = viteServer.moduleGraph.getModuleById("\0" + VIRTUAL_MODULE_ID);
<<<<<<< HEAD
  if (!virtualMod)
    return;
  viteServer.moduleGraph.invalidateModule(virtualMod);
}
=======
  if (!virtualMod) return;
  viteServer.moduleGraph.invalidateModule(virtualMod);
}
function normalizeConfigPath(from, to) {
  const configPath = path.relative(from, to).replace(/\.ts$/, ".js");
  const normalizedPath = configPath.replaceAll("\\", "/");
  return `"${isRelativePath(configPath) ? "" : "./"}${normalizedPath}"`;
}
const schemaCache = /* @__PURE__ */ new Map();
async function getContentLayerSchema(collection, collectionKey) {
  const cached = schemaCache.get(collectionKey);
  if (cached) {
    return cached;
  }
  if (collection?.type === CONTENT_LAYER_TYPE && typeof collection.loader === "object" && collection.loader.schema) {
    let schema = collection.loader.schema;
    if (typeof schema === "function") {
      schema = await schema();
    }
    if (schema) {
      schemaCache.set(collectionKey, await schema);
      return schema;
    }
  }
}
async function typeForCollection(collection, collectionKey) {
  if (collection?.schema) {
    return `InferEntrySchema<${collectionKey}>`;
  }
  if (collection?.type === CONTENT_LAYER_TYPE) {
    const schema = await getContentLayerSchema(collection, collectionKey);
    if (schema) {
      try {
        const zodToTs = await import("zod-to-ts");
        const ast = zodToTs.zodToTs(schema);
        return zodToTs.printNode(ast.node);
      } catch (err) {
        if (err.message.includes("Cannot find package 'typescript'")) {
          return "any";
        }
        throw err;
      }
    }
  }
  return "any";
}
>>>>>>> 08f40ceb (Initial)
async function writeContentFiles({
  fs,
  contentPaths,
  collectionEntryMap,
  typeTemplateContent,
  contentEntryTypes,
  contentConfig,
<<<<<<< HEAD
  viteServer
}) {
  let contentTypesStr = "";
  let dataTypesStr = "";
  for (const collectionKey of Object.keys(collectionEntryMap).sort()) {
    const collectionConfig = contentConfig == null ? void 0 : contentConfig.collections[JSON.parse(collectionKey)];
    const collection = collectionEntryMap[collectionKey];
    if ((collectionConfig == null ? void 0 : collectionConfig.type) && collection.type !== "unknown" && collection.type !== collectionConfig.type) {
      viteServer.ws.send({
=======
  viteServer,
  logger,
  settings
}) {
  let contentTypesStr = "";
  let dataTypesStr = "";
  const collectionSchemasDir = new URL(COLLECTIONS_DIR, settings.dotAstroDir);
  fs.mkdirSync(collectionSchemasDir, { recursive: true });
  for (const [collection, config] of Object.entries(contentConfig?.collections ?? {})) {
    collectionEntryMap[JSON.stringify(collection)] ??= {
      type: config.type,
      entries: {}
    };
  }
  let contentCollectionsMap = {};
  for (const collectionKey of Object.keys(collectionEntryMap).sort()) {
    const collectionConfig = contentConfig?.collections[JSON.parse(collectionKey)];
    const collection = collectionEntryMap[collectionKey];
    if (collectionConfig?.type && collection.type !== "unknown" && collectionConfig.type !== CONTENT_LAYER_TYPE && collection.type !== collectionConfig.type) {
      viteServer.hot.send({
>>>>>>> 08f40ceb (Initial)
        type: "error",
        err: new AstroError({
          ...AstroErrorData.ContentCollectionTypeMismatchError,
          message: AstroErrorData.ContentCollectionTypeMismatchError.message(
            collectionKey,
            collection.type,
            collectionConfig.type
          ),
          hint: collection.type === "data" ? "Try adding `type: 'data'` to your collection config." : void 0,
          location: {
            file: ""
<<<<<<< HEAD
            /** required for error overlay `ws` messages */
=======
>>>>>>> 08f40ceb (Initial)
          }
        })
      });
      return;
    }
    const resolvedType = collection.type === "unknown" ? (
      // Add empty / unknown collections to the data type map by default
      // This ensures `getCollection('empty-collection')` doesn't raise a type error
<<<<<<< HEAD
      (collectionConfig == null ? void 0 : collectionConfig.type) ?? "data"
    ) : collection.type;
    switch (resolvedType) {
      case "content":
        contentTypesStr += `${collectionKey}: {
`;
        for (const entryKey of Object.keys(collection.entries).sort()) {
          const entryMetadata = collection.entries[entryKey];
          const dataType = (collectionConfig == null ? void 0 : collectionConfig.schema) ? `InferEntrySchema<${collectionKey}>` : "any";
=======
      collectionConfig?.type ?? "data"
    ) : collection.type;
    const collectionEntryKeys = Object.keys(collection.entries).sort();
    const dataType = await typeForCollection(collectionConfig, collectionKey);
    switch (resolvedType) {
      case LIVE_CONTENT_TYPE:
        throw new AstroUserError(
          `Invalid definition for collection ${collectionKey}: Live content collections must be defined in "src/live.config.ts"`
        );
      case "content":
        if (collectionEntryKeys.length === 0) {
          contentTypesStr += `${collectionKey}: Record<string, {
  id: string;
  slug: string;
  body: string;
  collection: ${collectionKey};
  data: ${dataType};
  render(): Render[".md"];
}>;
`;
          break;
        }
        contentTypesStr += `${collectionKey}: {
`;
        for (const entryKey of collectionEntryKeys) {
          const entryMetadata = collection.entries[entryKey];
>>>>>>> 08f40ceb (Initial)
          const renderType = `{ render(): Render[${JSON.stringify(
            path.extname(JSON.parse(entryKey))
          )}] }`;
          const slugType = JSON.stringify(entryMetadata.slug);
          contentTypesStr += `${entryKey}: {
	id: ${entryKey};
  slug: ${slugType};
  body: string;
  collection: ${collectionKey};
  data: ${dataType}
} & ${renderType};
`;
        }
        contentTypesStr += `};
`;
        break;
<<<<<<< HEAD
      case "data":
        dataTypesStr += `${collectionKey}: {
`;
        for (const entryKey of Object.keys(collection.entries).sort()) {
          const dataType = (collectionConfig == null ? void 0 : collectionConfig.schema) ? `InferEntrySchema<${collectionKey}>` : "any";
          dataTypesStr += `${entryKey}: {
=======
      case CONTENT_LAYER_TYPE:
        const legacyTypes = collectionConfig?._legacy ? 'render(): Render[".md"];\n  slug: string;\n  body: string;\n' : "body?: string;\n";
        dataTypesStr += `${collectionKey}: Record<string, {
  id: string;
  ${legacyTypes}  collection: ${collectionKey};
  data: ${dataType};
  rendered?: RenderedContent;
  filePath?: string;
}>;
`;
        break;
      case "data":
        if (collectionEntryKeys.length === 0) {
          dataTypesStr += `${collectionKey}: Record<string, {
  id: string;
  collection: ${collectionKey};
  data: ${dataType};
}>;
`;
        } else {
          dataTypesStr += `${collectionKey}: {
`;
          for (const entryKey of collectionEntryKeys) {
            dataTypesStr += `${entryKey}: {
>>>>>>> 08f40ceb (Initial)
	id: ${entryKey};
  collection: ${collectionKey};
  data: ${dataType}
};
`;
<<<<<<< HEAD
        }
        dataTypesStr += `};
`;
        break;
    }
  }
  if (!fs.existsSync(contentPaths.cacheDir)) {
    fs.mkdirSync(contentPaths.cacheDir, { recursive: true });
  }
  let configPathRelativeToCacheDir = normalizePath(
    path.relative(contentPaths.cacheDir.pathname, contentPaths.config.url.pathname)
  );
  if (!isRelativePath(configPathRelativeToCacheDir))
    configPathRelativeToCacheDir = "./" + configPathRelativeToCacheDir;
  if (configPathRelativeToCacheDir.endsWith(".ts")) {
    configPathRelativeToCacheDir = configPathRelativeToCacheDir.replace(/\.ts$/, "");
  }
=======
          }
          dataTypesStr += `};
`;
        }
        break;
    }
    if (collectionConfig && (collectionConfig.schema || await getContentLayerSchema(collectionConfig, collectionKey))) {
      await generateJSONSchema(fs, collectionConfig, collectionKey, collectionSchemasDir, logger);
      contentCollectionsMap[collectionKey] = collection;
    }
  }
  if (settings.config.experimental.contentIntellisense) {
    let contentCollectionManifest = {
      collections: [],
      entries: {}
    };
    Object.entries(contentCollectionsMap).forEach(([collectionKey, collection]) => {
      const collectionConfig = contentConfig?.collections[JSON.parse(collectionKey)];
      const key = JSON.parse(collectionKey);
      contentCollectionManifest.collections.push({
        hasSchema: Boolean(collectionConfig?.schema || schemaCache.has(collectionKey)),
        name: key
      });
      Object.keys(collection.entries).forEach((entryKey) => {
        const entryPath = new URL(
          JSON.parse(entryKey),
          contentPaths.contentDir + `${key}/`
        ).toString();
        contentCollectionManifest.entries[entryPath.toLowerCase()] = key;
      });
    });
    await fs.promises.writeFile(
      new URL("./collections.json", collectionSchemasDir),
      JSON.stringify(contentCollectionManifest, null, 2)
    );
  }
  const configPathRelativeToCacheDir = normalizeConfigPath(
    settings.dotAstroDir.pathname,
    contentPaths.config.url.pathname
  );
  const liveConfigPathRelativeToCacheDir = contentPaths.liveConfig?.exists ? normalizeConfigPath(settings.dotAstroDir.pathname, contentPaths.liveConfig.url.pathname) : void 0;
>>>>>>> 08f40ceb (Initial)
  for (const contentEntryType of contentEntryTypes) {
    if (contentEntryType.contentModuleTypes) {
      typeTemplateContent = contentEntryType.contentModuleTypes + "\n" + typeTemplateContent;
    }
  }
<<<<<<< HEAD
  typeTemplateContent = typeTemplateContent.replace("// @@CONTENT_ENTRY_MAP@@", contentTypesStr);
  typeTemplateContent = typeTemplateContent.replace("// @@DATA_ENTRY_MAP@@", dataTypesStr);
  typeTemplateContent = typeTemplateContent.replace(
    "'@@CONTENT_CONFIG_TYPE@@'",
    contentConfig ? `typeof import(${JSON.stringify(configPathRelativeToCacheDir)})` : "never"
  );
  await fs.promises.writeFile(
    new URL(CONTENT_TYPES_FILE, contentPaths.cacheDir),
    typeTemplateContent
  );
}
function warnNonexistentCollections({
  contentConfig,
  collectionEntryMap,
  logging
}) {
  for (const configuredCollection in contentConfig.collections) {
    if (!collectionEntryMap[JSON.stringify(configuredCollection)]) {
      warn(
        logging,
        "content",
        `The ${JSON.stringify(
          configuredCollection
        )} collection does not have an associated folder in your \`content\` directory. Make sure the folder exists, or check your content config for typos.`
      );
    }
=======
  typeTemplateContent = typeTemplateContent.replace("// @@CONTENT_ENTRY_MAP@@", contentTypesStr).replace("// @@DATA_ENTRY_MAP@@", dataTypesStr).replace(
    "'@@CONTENT_CONFIG_TYPE@@'",
    contentConfig ? `typeof import(${configPathRelativeToCacheDir})` : "never"
  ).replace(
    "'@@LIVE_CONTENT_CONFIG_TYPE@@'",
    liveConfigPathRelativeToCacheDir ? `typeof import(${liveConfigPathRelativeToCacheDir})` : "never"
  );
  if (settings.injectedTypes.some((t) => t.filename === CONTENT_TYPES_FILE)) {
    await fs.promises.writeFile(
      new URL(CONTENT_TYPES_FILE, settings.dotAstroDir),
      typeTemplateContent,
      "utf-8"
    );
  } else {
    settings.injectedTypes.push({
      filename: CONTENT_TYPES_FILE,
      content: typeTemplateContent
    });
  }
}
async function generateJSONSchema(fsMod, collectionConfig, collectionKey, collectionSchemasDir, logger) {
  let zodSchemaForJson = typeof collectionConfig.schema === "function" ? collectionConfig.schema({ image: () => z.string() }) : collectionConfig.schema;
  if (!zodSchemaForJson && collectionConfig.type === CONTENT_LAYER_TYPE) {
    zodSchemaForJson = await getContentLayerSchema(collectionConfig, collectionKey);
  }
  if (zodSchemaForJson instanceof z.ZodObject) {
    zodSchemaForJson = zodSchemaForJson.extend({
      $schema: z.string().optional()
    });
  }
  try {
    await fsMod.promises.writeFile(
      new URL(`./${collectionKey.replace(/"/g, "")}.schema.json`, collectionSchemasDir),
      JSON.stringify(
        zodToJsonSchema(zodSchemaForJson, {
          name: collectionKey.replace(/"/g, ""),
          markdownDescription: true,
          errorMessages: true,
          // Fix for https://github.com/StefanTerdell/zod-to-json-schema/issues/110
          dateStrategy: ["format:date-time", "format:date", "integer"]
        }),
        null,
        2
      )
    );
  } catch (err) {
    logger.warn(
      "content",
      `An error was encountered while creating the JSON schema for the ${collectionKey} collection. Proceeding without it. Error: ${err}`
    );
>>>>>>> 08f40ceb (Initial)
  }
}
export {
  createContentTypesGenerator
};
