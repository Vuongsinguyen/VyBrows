import { extname } from "node:path";
<<<<<<< HEAD
import { pathToFileURL } from "node:url";
import { moduleIsTopLevelPage, walkParentInfos } from "../core/build/graph.js";
import { getPageDataByViteID } from "../core/build/internal.js";
import { createViteLoader } from "../core/module-loader/vite.js";
import { joinPaths, prependForwardSlash } from "../core/path.js";
import { getStylesForURL } from "../vite-plugin-astro-server/css.js";
import { getScriptsForURL } from "../vite-plugin-astro-server/scripts.js";
import {
  CONTENT_RENDER_FLAG,
  LINKS_PLACEHOLDER,
  PROPAGATED_ASSET_FLAG,
  SCRIPTS_PLACEHOLDER,
=======
import { fileURLToPath, pathToFileURL } from "node:url";
import { getAssetsPrefix } from "../assets/utils/getAssetsPrefix.js";
import { AstroError, AstroErrorData } from "../core/errors/index.js";
import { createViteLoader } from "../core/module-loader/vite.js";
import { joinPaths, prependForwardSlash } from "../core/path.js";
import { getStylesForURL } from "../vite-plugin-astro-server/css.js";
import {
  CONTENT_IMAGE_FLAG,
  CONTENT_RENDER_FLAG,
  LINKS_PLACEHOLDER,
  PROPAGATED_ASSET_FLAG,
>>>>>>> 08f40ceb (Initial)
  STYLES_PLACEHOLDER
} from "./consts.js";
import { hasContentFlag } from "./utils.js";
function astroContentAssetPropagationPlugin({
<<<<<<< HEAD
  mode,
=======
>>>>>>> 08f40ceb (Initial)
  settings
}) {
  let devModuleLoader;
  return {
    name: "astro:content-asset-propagation",
    enforce: "pre",
    async resolveId(id, importer, opts) {
<<<<<<< HEAD
=======
      if (hasContentFlag(id, CONTENT_IMAGE_FLAG)) {
        const [base, query] = id.split("?");
        const params = new URLSearchParams(query);
        const importerParam = params.get("importer");
        const importerPath = importerParam ? fileURLToPath(new URL(importerParam, settings.config.root)) : importer;
        const resolved = await this.resolve(base, importerPath, { skipSelf: true, ...opts });
        if (!resolved) {
          throw new AstroError({
            ...AstroErrorData.ImageNotFound,
            message: AstroErrorData.ImageNotFound.message(base)
          });
        }
        return resolved;
      }
>>>>>>> 08f40ceb (Initial)
      if (hasContentFlag(id, CONTENT_RENDER_FLAG)) {
        const base = id.split("?")[0];
        for (const { extensions, handlePropagation = true } of settings.contentEntryTypes) {
          if (handlePropagation && extensions.includes(extname(base))) {
            return this.resolve(`${base}?${PROPAGATED_ASSET_FLAG}`, importer, {
              skipSelf: true,
              ...opts
            });
          }
        }
        return this.resolve(base, importer, { skipSelf: true, ...opts });
      }
    },
    configureServer(server) {
<<<<<<< HEAD
      if (mode === "dev") {
        devModuleLoader = createViteLoader(server);
      }
    },
    async transform(_, id, options) {
      var _a;
      if (hasContentFlag(id, PROPAGATED_ASSET_FLAG)) {
        const basePath = id.split("?")[0];
        let stringifiedLinks, stringifiedStyles, stringifiedScripts;
        if ((options == null ? void 0 : options.ssr) && devModuleLoader) {
          if (!((_a = devModuleLoader.getModuleById(basePath)) == null ? void 0 : _a.ssrModule)) {
            await devModuleLoader.import(basePath);
          }
          const { stylesMap, urls } = await getStylesForURL(
            pathToFileURL(basePath),
            devModuleLoader,
            "development"
          );
          const hoistedScripts = await getScriptsForURL(
            pathToFileURL(basePath),
            settings.config.root,
            devModuleLoader
          );
          stringifiedLinks = JSON.stringify([...urls]);
          stringifiedStyles = JSON.stringify([...stylesMap.values()]);
          stringifiedScripts = JSON.stringify([...hoistedScripts]);
        } else {
          stringifiedLinks = JSON.stringify(LINKS_PLACEHOLDER);
          stringifiedStyles = JSON.stringify(STYLES_PLACEHOLDER);
          stringifiedScripts = JSON.stringify(SCRIPTS_PLACEHOLDER);
=======
      devModuleLoader = createViteLoader(server);
    },
    async transform(_, id, options) {
      if (hasContentFlag(id, PROPAGATED_ASSET_FLAG)) {
        const basePath = id.split("?")[0];
        let stringifiedLinks, stringifiedStyles;
        if (options?.ssr && devModuleLoader) {
          if (!devModuleLoader.getModuleById(basePath)?.ssrModule) {
            await devModuleLoader.import(basePath);
          }
          const {
            styles,
            urls,
            crawledFiles: styleCrawledFiles
          } = await getStylesForURL(pathToFileURL(basePath), devModuleLoader);
          for (const file of styleCrawledFiles) {
            if (!file.includes("node_modules")) {
              this.addWatchFile(file);
            }
          }
          stringifiedLinks = JSON.stringify([...urls]);
          stringifiedStyles = JSON.stringify(styles.map((s) => s.content));
        } else {
          stringifiedLinks = JSON.stringify(LINKS_PLACEHOLDER);
          stringifiedStyles = JSON.stringify(STYLES_PLACEHOLDER);
>>>>>>> 08f40ceb (Initial)
        }
        const code = `
					async function getMod() {
						return import(${JSON.stringify(basePath)});
					}
					const collectedLinks = ${stringifiedLinks};
					const collectedStyles = ${stringifiedStyles};
<<<<<<< HEAD
					const collectedScripts = ${stringifiedScripts};
					const defaultMod = { __astroPropagation: true, getMod, collectedLinks, collectedStyles, collectedScripts };
=======
					const defaultMod = { __astroPropagation: true, getMod, collectedLinks, collectedStyles, collectedScripts: [] };
>>>>>>> 08f40ceb (Initial)
					export default defaultMod;
				`;
        return { code, map: { mappings: "" } };
      }
    }
  };
}
function astroConfigBuildPlugin(options, internals) {
<<<<<<< HEAD
  let ssrPluginContext = void 0;
  return {
    build: "ssr",
    hooks: {
      "build:before": ({ build }) => {
        return {
          vitePlugin: {
            name: "astro:content-build-plugin",
            generateBundle() {
              if (build === "ssr") {
                ssrPluginContext = this;
              }
            }
          }
        };
      },
      "build:post": ({ ssrOutputs, clientOutputs, mutate }) => {
        var _a, _b;
        const outputs = ssrOutputs.flatMap((o) => o.output);
        const prependBase = (src) => {
          if (options.settings.config.build.assetsPrefix) {
            return joinPaths(options.settings.config.build.assetsPrefix, src);
=======
  return {
    targets: ["server"],
    hooks: {
      "build:post": ({ ssrOutputs, mutate }) => {
        const outputs = ssrOutputs.flatMap((o) => o.output);
        const prependBase = (src) => {
          const { assetsPrefix } = options.settings.config.build;
          if (assetsPrefix) {
            const fileExtension = extname(src);
            const pf = getAssetsPrefix(fileExtension, assetsPrefix);
            return joinPaths(pf, src);
>>>>>>> 08f40ceb (Initial)
          } else {
            return prependForwardSlash(joinPaths(options.settings.config.base, src));
          }
        };
        for (const chunk of outputs) {
<<<<<<< HEAD
          if (chunk.type === "chunk" && (chunk.code.includes(LINKS_PLACEHOLDER) || chunk.code.includes(SCRIPTS_PLACEHOLDER))) {
            let entryStyles = /* @__PURE__ */ new Set();
            let entryLinks = /* @__PURE__ */ new Set();
            let entryScripts = /* @__PURE__ */ new Set();
            for (const id of Object.keys(chunk.modules)) {
              for (const [pageInfo] of walkParentInfos(id, ssrPluginContext)) {
                if (moduleIsTopLevelPage(pageInfo)) {
                  const pageViteID = pageInfo.id;
                  const pageData = getPageDataByViteID(internals, pageViteID);
                  if (!pageData)
                    continue;
                  const _entryCss = (_a = pageData.propagatedStyles) == null ? void 0 : _a.get(id);
                  const _entryScripts = (_b = pageData.propagatedScripts) == null ? void 0 : _b.get(id);
                  if (_entryCss) {
                    for (const value of _entryCss) {
                      if (value.type === "inline")
                        entryStyles.add(value.content);
                      if (value.type === "external")
                        entryLinks.add(value.src);
                    }
                  }
                  if (_entryScripts) {
                    for (const value of _entryScripts) {
                      entryScripts.add(value);
                    }
                  }
=======
          if (chunk.type === "chunk" && chunk.code.includes(LINKS_PLACEHOLDER)) {
            const entryStyles = /* @__PURE__ */ new Set();
            const entryLinks = /* @__PURE__ */ new Set();
            for (const id of chunk.moduleIds) {
              const _entryCss = internals.propagatedStylesMap.get(id);
              if (_entryCss) {
                for (const value of _entryCss) {
                  if (value.type === "inline") entryStyles.add(value.content);
                  if (value.type === "external") entryLinks.add(value.src);
>>>>>>> 08f40ceb (Initial)
                }
              }
            }
            let newCode = chunk.code;
            if (entryStyles.size) {
              newCode = newCode.replace(
                JSON.stringify(STYLES_PLACEHOLDER),
                JSON.stringify(Array.from(entryStyles))
              );
<<<<<<< HEAD
=======
            } else {
              newCode = newCode.replace(JSON.stringify(STYLES_PLACEHOLDER), "[]");
>>>>>>> 08f40ceb (Initial)
            }
            if (entryLinks.size) {
              newCode = newCode.replace(
                JSON.stringify(LINKS_PLACEHOLDER),
                JSON.stringify(Array.from(entryLinks).map(prependBase))
              );
<<<<<<< HEAD
            }
            if (entryScripts.size) {
              const entryFileNames = /* @__PURE__ */ new Set();
              for (const output of clientOutputs) {
                for (const clientChunk of output.output) {
                  if (clientChunk.type !== "chunk")
                    continue;
                  for (const [id] of Object.entries(clientChunk.modules)) {
                    if (entryScripts.has(id)) {
                      entryFileNames.add(clientChunk.fileName);
                    }
                  }
                }
              }
              newCode = newCode.replace(
                JSON.stringify(SCRIPTS_PLACEHOLDER),
                JSON.stringify(
                  [...entryFileNames].map((src) => ({
                    props: {
                      src: prependBase(src),
                      type: "module"
                    },
                    children: ""
                  }))
                )
              );
            }
            mutate(chunk, "server", newCode);
=======
            } else {
              newCode = newCode.replace(JSON.stringify(LINKS_PLACEHOLDER), "[]");
            }
            mutate(chunk, ["server"], newCode);
>>>>>>> 08f40ceb (Initial)
          }
        }
      }
    }
  };
}
export {
  astroConfigBuildPlugin,
  astroContentAssetPropagationPlugin
};
