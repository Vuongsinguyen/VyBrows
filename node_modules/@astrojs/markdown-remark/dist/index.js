<<<<<<< HEAD
import { toRemarkInitializeAstroData } from "./frontmatter-injection.js";
import { loadPlugins } from "./load-plugins.js";
import { rehypeHeadingIds } from "./rehype-collect-headings.js";
import { remarkCollectImages } from "./remark-collect-images.js";
import remarkPrism from "./remark-prism.js";
import scopedStyles from "./remark-scoped-styles.js";
import remarkShiki from "./remark-shiki.js";
import rehypeRaw from "rehype-raw";
import rehypeStringify from "rehype-stringify";
import remarkGfm from "remark-gfm";
import markdown from "remark-parse";
import markdownToHtml from "remark-rehype";
import remarkSmartypants from "remark-smartypants";
import { unified } from "unified";
import { VFile } from "vfile";
import { rehypeImages } from "./rehype-images.js";
import { rehypeHeadingIds as rehypeHeadingIds2 } from "./rehype-collect-headings.js";
import { remarkCollectImages as remarkCollectImages2 } from "./remark-collect-images.js";
export * from "./types.js";
const markdownConfigDefaults = {
  syntaxHighlight: "shiki",
  shikiConfig: {
    langs: [],
    theme: "github-dark",
    wrap: false
=======
import rehypeRaw from "rehype-raw";
import rehypeStringify from "rehype-stringify";
import remarkGfm from "remark-gfm";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import remarkSmartypants from "remark-smartypants";
import { unified } from "unified";
import { VFile } from "vfile";
import { defaultExcludeLanguages } from "./highlight.js";
import { loadPlugins } from "./load-plugins.js";
import { rehypeHeadingIds } from "./rehype-collect-headings.js";
import { rehypeImages } from "./rehype-images.js";
import { rehypePrism } from "./rehype-prism.js";
import { rehypeShiki } from "./rehype-shiki.js";
import { remarkCollectImages } from "./remark-collect-images.js";
import {
  extractFrontmatter,
  isFrontmatterValid,
  parseFrontmatter
} from "./frontmatter.js";
import { rehypeHeadingIds as rehypeHeadingIds2 } from "./rehype-collect-headings.js";
import { rehypePrism as rehypePrism2 } from "./rehype-prism.js";
import { rehypeShiki as rehypeShiki2 } from "./rehype-shiki.js";
import { remarkCollectImages as remarkCollectImages2 } from "./remark-collect-images.js";
import {
  createShikiHighlighter
} from "./shiki.js";
export * from "./types.js";
const syntaxHighlightDefaults = {
  type: "shiki",
  excludeLangs: defaultExcludeLanguages
};
const markdownConfigDefaults = {
  syntaxHighlight: syntaxHighlightDefaults,
  shikiConfig: {
    langs: [],
    theme: "github-dark",
    themes: {},
    wrap: false,
    transformers: [],
    langAlias: {}
>>>>>>> 08f40ceb (Initial)
  },
  remarkPlugins: [],
  rehypePlugins: [],
  remarkRehype: {},
  gfm: true,
  smartypants: true
};
const isPerformanceBenchmark = Boolean(process.env.ASTRO_PERFORMANCE_BENCHMARK);
<<<<<<< HEAD
async function renderMarkdown(content, opts) {
  var _a;
  let {
    fileURL,
=======
async function createMarkdownProcessor(opts) {
  const {
>>>>>>> 08f40ceb (Initial)
    syntaxHighlight = markdownConfigDefaults.syntaxHighlight,
    shikiConfig = markdownConfigDefaults.shikiConfig,
    remarkPlugins = markdownConfigDefaults.remarkPlugins,
    rehypePlugins = markdownConfigDefaults.rehypePlugins,
<<<<<<< HEAD
    remarkRehype = markdownConfigDefaults.remarkRehype,
    gfm = markdownConfigDefaults.gfm,
    smartypants = markdownConfigDefaults.smartypants,
    frontmatter: userFrontmatter = {}
  } = opts;
  const input = new VFile({ value: content, path: fileURL });
  const scopedClassName = (_a = opts.$) == null ? void 0 : _a.scopedClassName;
  let parser = unified().use(markdown).use(toRemarkInitializeAstroData({ userFrontmatter })).use([]);
  if (!isPerformanceBenchmark && gfm) {
=======
    remarkRehype: remarkRehypeOptions = markdownConfigDefaults.remarkRehype,
    gfm = markdownConfigDefaults.gfm,
    smartypants = markdownConfigDefaults.smartypants,
    experimentalHeadingIdCompat = false
  } = opts ?? {};
  const loadedRemarkPlugins = await Promise.all(loadPlugins(remarkPlugins));
  const loadedRehypePlugins = await Promise.all(loadPlugins(rehypePlugins));
  const parser = unified().use(remarkParse);
  if (!isPerformanceBenchmark) {
>>>>>>> 08f40ceb (Initial)
    if (gfm) {
      parser.use(remarkGfm);
    }
    if (smartypants) {
      parser.use(remarkSmartypants);
    }
  }
<<<<<<< HEAD
  const loadedRemarkPlugins = await Promise.all(loadPlugins(remarkPlugins));
  const loadedRehypePlugins = await Promise.all(loadPlugins(rehypePlugins));
  loadedRemarkPlugins.forEach(([plugin, pluginOpts]) => {
    parser.use([[plugin, pluginOpts]]);
  });
  if (!isPerformanceBenchmark) {
    if (scopedClassName) {
      parser.use([scopedStyles(scopedClassName)]);
    }
    if (syntaxHighlight === "shiki") {
      parser.use([await remarkShiki(shikiConfig, scopedClassName)]);
    } else if (syntaxHighlight === "prism") {
      parser.use([remarkPrism(scopedClassName)]);
    }
    if (opts.experimentalAssets) {
      parser.use([remarkCollectImages]);
    }
  }
  parser.use([
    [
      markdownToHtml,
      {
        allowDangerousHtml: true,
        passThrough: [],
        ...remarkRehype
      }
    ]
  ]);
  loadedRehypePlugins.forEach(([plugin, pluginOpts]) => {
    parser.use([[plugin, pluginOpts]]);
  });
  if (opts.experimentalAssets) {
    parser.use(rehypeImages());
  }
  if (!isPerformanceBenchmark) {
    parser.use([rehypeHeadingIds]);
  }
  parser.use([rehypeRaw]).use(rehypeStringify, { allowDangerousHtml: true });
  let vfile;
  try {
    vfile = await parser.process(input);
  } catch (err) {
    err = prefixError(err, `Failed to parse Markdown file "${input.path}"`);
    console.error(err);
    throw err;
  }
  const headings = (vfile == null ? void 0 : vfile.data.__astroHeadings) || [];
  return {
    metadata: { headings, source: content, html: String(vfile.value) },
    code: String(vfile.value),
    vfile
  };
}
function prefixError(err, prefix) {
  if (err && err.message) {
=======
  for (const [plugin, pluginOpts] of loadedRemarkPlugins) {
    parser.use(plugin, pluginOpts);
  }
  if (!isPerformanceBenchmark) {
    parser.use(remarkCollectImages, opts?.image);
  }
  parser.use(remarkRehype, {
    allowDangerousHtml: true,
    passThrough: [],
    ...remarkRehypeOptions
  });
  if (syntaxHighlight && !isPerformanceBenchmark) {
    const syntaxHighlightType = typeof syntaxHighlight === "string" ? syntaxHighlight : syntaxHighlight?.type;
    const excludeLangs = typeof syntaxHighlight === "object" ? syntaxHighlight?.excludeLangs : void 0;
    if (syntaxHighlightType === "shiki") {
      parser.use(rehypeShiki, shikiConfig, excludeLangs);
    } else if (syntaxHighlightType === "prism") {
      parser.use(rehypePrism, excludeLangs);
    }
  }
  for (const [plugin, pluginOpts] of loadedRehypePlugins) {
    parser.use(plugin, pluginOpts);
  }
  parser.use(rehypeImages);
  if (!isPerformanceBenchmark) {
    parser.use(rehypeHeadingIds, { experimentalHeadingIdCompat });
  }
  parser.use(rehypeRaw).use(rehypeStringify, { allowDangerousHtml: true });
  return {
    async render(content, renderOpts) {
      const vfile = new VFile({
        value: content,
        path: renderOpts?.fileURL,
        data: {
          astro: {
            frontmatter: renderOpts?.frontmatter ?? {}
          }
        }
      });
      const result = await parser.process(vfile).catch((err) => {
        err = prefixError(err, `Failed to parse Markdown file "${vfile.path}"`);
        console.error(err);
        throw err;
      });
      return {
        code: String(result.value),
        metadata: {
          headings: result.data.astro?.headings ?? [],
          localImagePaths: result.data.astro?.localImagePaths ?? [],
          remoteImagePaths: result.data.astro?.remoteImagePaths ?? [],
          frontmatter: result.data.astro?.frontmatter ?? {}
        }
      };
    }
  };
}
function prefixError(err, prefix) {
  if (err?.message) {
>>>>>>> 08f40ceb (Initial)
    try {
      err.message = `${prefix}:
${err.message}`;
      return err;
<<<<<<< HEAD
    } catch (error) {
=======
    } catch {
>>>>>>> 08f40ceb (Initial)
    }
  }
  const wrappedError = new Error(`${prefix}${err ? `: ${err}` : ""}`);
  try {
    wrappedError.stack = err.stack;
    wrappedError.cause = err;
<<<<<<< HEAD
  } catch (error) {
=======
  } catch {
>>>>>>> 08f40ceb (Initial)
  }
  return wrappedError;
}
export {
<<<<<<< HEAD
  markdownConfigDefaults,
  rehypeHeadingIds2 as rehypeHeadingIds,
  remarkCollectImages2 as remarkCollectImages,
  renderMarkdown
=======
  createMarkdownProcessor,
  createShikiHighlighter,
  extractFrontmatter,
  isFrontmatterValid,
  markdownConfigDefaults,
  parseFrontmatter,
  rehypeHeadingIds2 as rehypeHeadingIds,
  rehypePrism2 as rehypePrism,
  rehypeShiki2 as rehypeShiki,
  remarkCollectImages2 as remarkCollectImages,
  syntaxHighlightDefaults
>>>>>>> 08f40ceb (Initial)
};
