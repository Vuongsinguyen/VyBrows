/**
 * While micromark is a lexer/tokenizer, the common case of going from markdown
 * to html is currently built in as this module, even though the parts can be
 * used separately to build ASTs, CSTs, or many other output formats.
 *
 * Having an HTML compiler built in is useful because it allows us to check for
 * compliancy to CommonMark, the de facto norm of markdown, specified in roughly
 * 600 input/output cases.
 *
 * This module has an interface that accepts lists of events instead of the
 * whole at once, however, because markdown can’t be truly streaming, we buffer
 * events before processing and outputting the final result.
 */

/**
<<<<<<< HEAD
 * @typedef {import('micromark-util-types').Compile} Compile
 * @typedef {import('micromark-util-types').CompileContext} CompileContext
 * @typedef {import('micromark-util-types').CompileData} CompileData
 * @typedef {import('micromark-util-types').CompileOptions} CompileOptions
 * @typedef {import('micromark-util-types').Definition} Definition
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Handle} Handle
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-util-types').NormalizedHtmlExtension} NormalizedHtmlExtension
 * @typedef {import('micromark-util-types').Token} Token
=======
 * @import {
 *   CompileContext,
 *   CompileData,
 *   CompileOptions,
 *   Compile,
 *   Definition,
 *   Event,
 *   Handle,
 *   HtmlExtension,
 *   LineEnding,
 *   NormalizedHtmlExtension,
 *   Token
 * } from 'micromark-util-types'
>>>>>>> 08f40ceb (Initial)
 */

/**
 * @typedef Media
 * @property {boolean | undefined} [image]
 * @property {string | undefined} [labelId]
 * @property {string | undefined} [label]
 * @property {string | undefined} [referenceId]
 * @property {string | undefined} [destination]
 * @property {string | undefined} [title]
 */

<<<<<<< HEAD
import {decodeNamedCharacterReference} from 'decode-named-character-reference'
import {push} from 'micromark-util-chunked'
import {combineHtmlExtensions} from 'micromark-util-combine-extensions'
import {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'
import {encode as _encode} from 'micromark-util-encode'
import {normalizeIdentifier} from 'micromark-util-normalize-identifier'
import {sanitizeUri} from 'micromark-util-sanitize-uri'
const hasOwnProperty = {}.hasOwnProperty
=======
import { decodeNamedCharacterReference } from 'decode-named-character-reference';
import { push } from 'micromark-util-chunked';
import { combineHtmlExtensions } from 'micromark-util-combine-extensions';
import { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';
import { encode as _encode } from 'micromark-util-encode';
import { normalizeIdentifier } from 'micromark-util-normalize-identifier';
import { sanitizeUri } from 'micromark-util-sanitize-uri';
const hasOwnProperty = {}.hasOwnProperty;
>>>>>>> 08f40ceb (Initial)

/**
 * These two are allowlists of safe protocols for full URLs in respectively the
 * `href` (on `<a>`) and `src` (on `<img>`) attributes.
 * They are based on what is allowed on GitHub,
 * <https://github.com/syntax-tree/hast-util-sanitize/blob/9275b21/lib/github.json#L31>
 */
<<<<<<< HEAD
const protocolHref = /^(https?|ircs?|mailto|xmpp)$/i
const protocolSrc = /^https?$/i
=======
const protocolHref = /^(https?|ircs?|mailto|xmpp)$/i;
const protocolSource = /^https?$/i;
>>>>>>> 08f40ceb (Initial)

/**
 * @param {CompileOptions | null | undefined} [options]
 * @returns {Compile}
 */
export function compile(options) {
<<<<<<< HEAD
  const settings = options || {}
=======
  const settings = options || {};
>>>>>>> 08f40ceb (Initial)

  /**
   * Tags is needed because according to markdown, links and emphasis and
   * whatnot can exist in images, however, as HTML doesn’t allow content in
   * images, the tags are ignored in the `alt` attribute, but the content
   * remains.
   *
   * @type {boolean | undefined}
   */
<<<<<<< HEAD
  let tags = true
=======
  let tags = true;
>>>>>>> 08f40ceb (Initial)

  /**
   * An object to track identifiers to media (URLs and titles) defined with
   * definitions.
   *
   * @type {Record<string, Definition>}
   */
<<<<<<< HEAD
  const definitions = {}
=======
  const definitions = {};
>>>>>>> 08f40ceb (Initial)

  /**
   * A lot of the handlers need to capture some of the output data, modify it
   * somehow, and then deal with it.
   * We do that by tracking a stack of buffers, that can be opened (with
   * `buffer`) and closed (with `resume`) to access them.
   *
   * @type {Array<Array<string>>}
   */
<<<<<<< HEAD
  const buffers = [[]]
=======
  const buffers = [[]];
>>>>>>> 08f40ceb (Initial)

  /**
   * As we can have links in images and the other way around, where the deepest
   * ones are closed first, we need to track which one we’re in.
   *
   * @type {Array<Media>}
   */
<<<<<<< HEAD
  const mediaStack = []
=======
  const mediaStack = [];
>>>>>>> 08f40ceb (Initial)

  /**
   * Same as `mediaStack` for tightness, which is specific to lists.
   * We need to track if we’re currently in a tight or loose container.
   *
   * @type {Array<boolean>}
   */
<<<<<<< HEAD
  const tightStack = []
=======
  const tightStack = [];
>>>>>>> 08f40ceb (Initial)

  /** @type {HtmlExtension} */
  const defaultHandlers = {
    enter: {
      blockQuote: onenterblockquote,
      codeFenced: onentercodefenced,
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: onentercodeindented,
      codeText: onentercodetext,
      content: onentercontent,
      definition: onenterdefinition,
      definitionDestinationString: onenterdefinitiondestinationstring,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: onenteremphasis,
      htmlFlow: onenterhtmlflow,
      htmlText: onenterhtml,
      image: onenterimage,
      label: buffer,
      link: onenterlink,
      listItemMarker: onenterlistitemmarker,
      listItemValue: onenterlistitemvalue,
      listOrdered: onenterlistordered,
      listUnordered: onenterlistunordered,
      paragraph: onenterparagraph,
      reference: buffer,
      resource: onenterresource,
      resourceDestinationString: onenterresourcedestinationstring,
      resourceTitleString: buffer,
      setextHeading: onentersetextheading,
      strong: onenterstrong
    },
    exit: {
      atxHeading: onexitatxheading,
      atxHeadingSequence: onexitatxheadingsequence,
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: onexitblockquote,
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: onexitflowcode,
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
<<<<<<< HEAD
      codeFencedFenceMeta: resume,
=======
      codeFencedFenceMeta: onresumedrop,
>>>>>>> 08f40ceb (Initial)
      codeFlowValue: onexitcodeflowvalue,
      codeIndented: onexitflowcode,
      codeText: onexitcodetext,
      codeTextData: onexitdata,
      data: onexitdata,
      definition: onexitdefinition,
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: onexitemphasis,
      hardBreakEscape: onexithardbreak,
      hardBreakTrailing: onexithardbreak,
      htmlFlow: onexithtml,
      htmlFlowData: onexitdata,
      htmlText: onexithtml,
      htmlTextData: onexitdata,
      image: onexitmedia,
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: onexitmedia,
      listOrdered: onexitlistordered,
      listUnordered: onexitlistunordered,
      paragraph: onexitparagraph,
<<<<<<< HEAD
      reference: resume,
      referenceString: onexitreferencestring,
      resource: resume,
=======
      reference: onresumedrop,
      referenceString: onexitreferencestring,
      resource: onresumedrop,
>>>>>>> 08f40ceb (Initial)
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      setextHeading: onexitsetextheading,
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: onexitstrong,
      thematicBreak: onexitthematicbreak
    }
<<<<<<< HEAD
  }
=======
  };
>>>>>>> 08f40ceb (Initial)

  /**
   * Combine the HTML extensions with the default handlers.
   * An HTML extension is an object whose fields are either `enter` or `exit`
   * (reflecting whether a token is entered or exited).
   * The values at such objects are names of tokens mapping to handlers.
   * Handlers are called, respectively when a token is opener or closed, with
   * that token, and a context as `this`.
   */
<<<<<<< HEAD
  const handlers =
    /** @type {NormalizedHtmlExtension} */
    combineHtmlExtensions(
      [defaultHandlers].concat(settings.htmlExtensions || [])
    )
=======
  const handlers = /** @type {NormalizedHtmlExtension} */
  combineHtmlExtensions([defaultHandlers, ...(settings.htmlExtensions || [])]);
>>>>>>> 08f40ceb (Initial)

  /**
   * Handlers do often need to keep track of some state.
   * That state is provided here as a key-value store (an object).
   *
   * @type {CompileData}
   */
  const data = {
<<<<<<< HEAD
    tightStack,
    definitions
  }
=======
    definitions,
    tightStack
  };
>>>>>>> 08f40ceb (Initial)

  /**
   * The context for handlers references a couple of useful functions.
   * In handlers from extensions, those can be accessed at `this`.
   * For the handlers here, they can be accessed directly.
   *
   * @type {Omit<CompileContext, 'sliceSerialize'>}
   */
  const context = {
<<<<<<< HEAD
    lineEndingIfNeeded,
    options: settings,
    encode,
    raw,
    tag,
    buffer,
    resume,
    setData,
    getData
  }
=======
    buffer,
    encode,
    getData,
    lineEndingIfNeeded,
    options: settings,
    raw,
    resume,
    setData,
    tag
  };
>>>>>>> 08f40ceb (Initial)

  /**
   * Generally, micromark copies line endings (`'\r'`, `'\n'`, `'\r\n'`) in the
   * markdown document over to the compiled HTML.
   * In some cases, such as `> a`, CommonMark requires that extra line endings
   * are added: `<blockquote>\n<p>a</p>\n</blockquote>`.
   * This variable hold the default line ending when given (or `undefined`),
   * and in the latter case will be updated to the first found line ending if
   * there is one.
   */
<<<<<<< HEAD
  let lineEndingStyle = settings.defaultLineEnding

  // Return the function that handles a slice of events.
  return compile
=======
  let lineEndingStyle = settings.defaultLineEnding;

  // Return the function that handles a slice of events.
  return compile;
>>>>>>> 08f40ceb (Initial)

  /**
   * Deal w/ a slice of events.
   * Return either the empty string if there’s nothing of note to return, or the
   * result when done.
   *
<<<<<<< HEAD
   * @param {Array<Event>} events
   * @returns {string}
   */
  function compile(events) {
    let index = -1
    let start = 0
    /** @type {Array<number>} */
    const listStack = []
=======
   * @param {ReadonlyArray<Event>} events
   * @returns {string}
   */
  function compile(events) {
    let index = -1;
    let start = 0;
    /** @type {Array<number>} */
    const listStack = [];
>>>>>>> 08f40ceb (Initial)
    // As definitions can come after references, we need to figure out the media
    // (urls and titles) defined by them before handling the references.
    // So, we do sort of what HTML does: put metadata at the start (in head), and
    // then put content after (`body`).
    /** @type {Array<Event>} */
<<<<<<< HEAD
    let head = []
    /** @type {Array<Event>} */
    let body = []
    while (++index < events.length) {
      // Figure out the line ending style used in the document.
      if (
        !lineEndingStyle &&
        (events[index][1].type === 'lineEnding' ||
          events[index][1].type === 'lineEndingBlank')
      ) {
        // @ts-expect-error Hush, it’s a line ending.
        lineEndingStyle = events[index][2].sliceSerialize(events[index][1])
      }

      // Preprocess lists to infer whether the list is loose or not.
      if (
        events[index][1].type === 'listOrdered' ||
        events[index][1].type === 'listUnordered'
      ) {
        if (events[index][0] === 'enter') {
          listStack.push(index)
        } else {
          prepareList(events.slice(listStack.pop(), index))
=======
    let head = [];
    /** @type {Array<Event>} */
    let body = [];
    while (++index < events.length) {
      // Figure out the line ending style used in the document.
      if (!lineEndingStyle && (events[index][1].type === "lineEnding" || events[index][1].type === "lineEndingBlank")) {
        lineEndingStyle = /** @type {LineEnding} */
        events[index][2].sliceSerialize(events[index][1]);
      }

      // Preprocess lists to infer whether the list is loose or not.
      if (events[index][1].type === "listOrdered" || events[index][1].type === "listUnordered") {
        if (events[index][0] === 'enter') {
          listStack.push(index);
        } else {
          prepareList(events.slice(listStack.pop(), index));
>>>>>>> 08f40ceb (Initial)
        }
      }

      // Move definitions to the front.
<<<<<<< HEAD
      if (events[index][1].type === 'definition') {
        if (events[index][0] === 'enter') {
          body = push(body, events.slice(start, index))
          start = index
        } else {
          head = push(head, events.slice(start, index + 1))
          start = index + 1
        }
      }
    }
    head = push(head, body)
    head = push(head, events.slice(start))
    index = -1
    const result = head

    // Handle the start of the document, if defined.
    if (handlers.enter.null) {
      handlers.enter.null.call(context)
=======
      if (events[index][1].type === "definition") {
        if (events[index][0] === 'enter') {
          body = push(body, events.slice(start, index));
          start = index;
        } else {
          head = push(head, events.slice(start, index + 1));
          start = index + 1;
        }
      }
    }
    head = push(head, body);
    head = push(head, events.slice(start));
    index = -1;
    const result = head;

    // Handle the start of the document, if defined.
    if (handlers.enter.null) {
      handlers.enter.null.call(context);
>>>>>>> 08f40ceb (Initial)
    }

    // Handle all events.
    while (++index < events.length) {
<<<<<<< HEAD
      const handles = handlers[result[index][0]]
      const kind = result[index][1].type
      const handle = handles[kind]
      if (hasOwnProperty.call(handles, kind) && handle) {
        handle.call(
          Object.assign(
            {
              sliceSerialize: result[index][2].sliceSerialize
            },
            context
          ),
          result[index][1]
        )
=======
      const handles = handlers[result[index][0]];
      const kind = result[index][1].type;
      const handle = handles[kind];
      if (hasOwnProperty.call(handles, kind) && handle) {
        handle.call({
          sliceSerialize: result[index][2].sliceSerialize,
          ...context
        }, result[index][1]);
>>>>>>> 08f40ceb (Initial)
      }
    }

    // Handle the end of the document, if defined.
    if (handlers.exit.null) {
<<<<<<< HEAD
      handlers.exit.null.call(context)
    }
    return buffers[0].join('')
=======
      handlers.exit.null.call(context);
    }
    return buffers[0].join('');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * Figure out whether lists are loose or not.
   *
<<<<<<< HEAD
   * @param {Array<Event>} slice
   * @returns {void}
   */
  function prepareList(slice) {
    const length = slice.length
    let index = 0 // Skip open.
    let containerBalance = 0
    let loose = false
    /** @type {boolean | undefined} */
    let atMarker
    while (++index < length) {
      const event = slice[index]
      if (event[1]._container) {
        atMarker = undefined
        if (event[0] === 'enter') {
          containerBalance++
        } else {
          containerBalance--
        }
      } else
        switch (event[1].type) {
          case 'listItemPrefix': {
            if (event[0] === 'exit') {
              atMarker = true
            }
            break
          }
          case 'linePrefix': {
            // Ignore

            break
          }
          case 'lineEndingBlank': {
            if (event[0] === 'enter' && !containerBalance) {
              if (atMarker) {
                atMarker = undefined
              } else {
                loose = true
              }
            }
            break
          }
          default: {
            atMarker = undefined
          }
        }
    }
    slice[0][1]._loose = loose
=======
   * @param {ReadonlyArray<Event>} slice
   * @returns {undefined}
   */
  function prepareList(slice) {
    const length = slice.length;
    let index = 0; // Skip open.
    let containerBalance = 0;
    let loose = false;
    /** @type {boolean | undefined} */
    let atMarker;
    while (++index < length) {
      const event = slice[index];
      if (event[1]._container) {
        atMarker = undefined;
        if (event[0] === 'enter') {
          containerBalance++;
        } else {
          containerBalance--;
        }
      } else switch (event[1].type) {
        case "listItemPrefix":
          {
            if (event[0] === 'exit') {
              atMarker = true;
            }
            break;
          }
        case "linePrefix":
          {
            // Ignore

            break;
          }
        case "lineEndingBlank":
          {
            if (event[0] === 'enter' && !containerBalance) {
              if (atMarker) {
                atMarker = undefined;
              } else {
                loose = true;
              }
            }
            break;
          }
        default:
          {
            atMarker = undefined;
          }
      }
    }
    slice[0][1]._loose = loose;
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @type {CompileContext['setData']}
   */
  function setData(key, value) {
    // @ts-expect-error: assume `value` is omitted (`undefined` is passed) only
    // if allowed.
<<<<<<< HEAD
    data[key] = value
=======
    data[key] = value;
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @type {CompileContext['getData']}
   */
  function getData(key) {
<<<<<<< HEAD
    return data[key]
=======
    return data[key];
>>>>>>> 08f40ceb (Initial)
  }

  /** @type {CompileContext['buffer']} */
  function buffer() {
<<<<<<< HEAD
    buffers.push([])
=======
    buffers.push([]);
>>>>>>> 08f40ceb (Initial)
  }

  /** @type {CompileContext['resume']} */
  function resume() {
<<<<<<< HEAD
    const buf = buffers.pop()
    return buf.join('')
=======
    const buf = buffers.pop();
    return buf.join('');
>>>>>>> 08f40ceb (Initial)
  }

  /** @type {CompileContext['tag']} */
  function tag(value) {
<<<<<<< HEAD
    if (!tags) return
    setData('lastWasTag', true)
    buffers[buffers.length - 1].push(value)
=======
    if (!tags) return;
    setData('lastWasTag', true);
    buffers[buffers.length - 1].push(value);
>>>>>>> 08f40ceb (Initial)
  }

  /** @type {CompileContext['raw']} */
  function raw(value) {
<<<<<<< HEAD
    setData('lastWasTag')
    buffers[buffers.length - 1].push(value)
=======
    setData('lastWasTag');
    buffers[buffers.length - 1].push(value);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * Output an extra line ending.
   *
<<<<<<< HEAD
   * @returns {void}
   */
  function lineEnding() {
    raw(lineEndingStyle || '\n')
=======
   * @returns {undefined}
   */
  function lineEnding() {
    raw(lineEndingStyle || '\n');
>>>>>>> 08f40ceb (Initial)
  }

  /** @type {CompileContext['lineEndingIfNeeded']} */
  function lineEndingIfNeeded() {
<<<<<<< HEAD
    const buffer = buffers[buffers.length - 1]
    const slice = buffer[buffer.length - 1]
    const previous = slice ? slice.charCodeAt(slice.length - 1) : null
    if (previous === 10 || previous === 13 || previous === null) {
      return
    }
    lineEnding()
=======
    const buffer = buffers[buffers.length - 1];
    const slice = buffer[buffer.length - 1];
    const previous = slice ? slice.charCodeAt(slice.length - 1) : null;
    if (previous === 10 || previous === 13 || previous === null) {
      return;
    }
    lineEnding();
>>>>>>> 08f40ceb (Initial)
  }

  /** @type {CompileContext['encode']} */
  function encode(value) {
<<<<<<< HEAD
    return getData('ignoreEncode') ? value : _encode(value)
=======
    return getData('ignoreEncode') ? value : _encode(value);
>>>>>>> 08f40ceb (Initial)
  }

  //
  // Handlers.
  //

  /**
<<<<<<< HEAD
=======
   * @returns {undefined}
   */
  function onresumedrop() {
    resume();
  }

  /**
>>>>>>> 08f40ceb (Initial)
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlistordered(token) {
<<<<<<< HEAD
    tightStack.push(!token._loose)
    lineEndingIfNeeded()
    tag('<ol')
    setData('expectFirstItem', true)
=======
    tightStack.push(!token._loose);
    lineEndingIfNeeded();
    tag('<ol');
    setData('expectFirstItem', true);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlistunordered(token) {
<<<<<<< HEAD
    tightStack.push(!token._loose)
    lineEndingIfNeeded()
    tag('<ul')
    setData('expectFirstItem', true)
=======
    tightStack.push(!token._loose);
    lineEndingIfNeeded();
    tag('<ul');
    setData('expectFirstItem', true);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlistitemvalue(token) {
    if (getData('expectFirstItem')) {
<<<<<<< HEAD
      const value = Number.parseInt(this.sliceSerialize(token), 10)
      if (value !== 1) {
        tag(' start="' + encode(String(value)) + '"')
      }
    }
  }
  function onenterlistitemmarker() {
    if (getData('expectFirstItem')) {
      tag('>')
    } else {
      onexitlistitem()
    }
    lineEndingIfNeeded()
    tag('<li>')
    setData('expectFirstItem')
    // “Hack” to prevent a line ending from showing up if the item is empty.
    setData('lastWasTag')
  }
  function onexitlistordered() {
    onexitlistitem()
    tightStack.pop()
    lineEnding()
    tag('</ol>')
  }
  function onexitlistunordered() {
    onexitlistitem()
    tightStack.pop()
    lineEnding()
    tag('</ul>')
  }
  function onexitlistitem() {
    if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {
      lineEndingIfNeeded()
    }
    tag('</li>')
    setData('slurpAllLineEndings')
=======
      const value = Number.parseInt(this.sliceSerialize(token), 10);
      if (value !== 1) {
        tag(' start="' + encode(String(value)) + '"');
      }
    }
  }

  /**
   * @returns {undefined}
   */
  function onenterlistitemmarker() {
    if (getData('expectFirstItem')) {
      tag('>');
    } else {
      onexitlistitem();
    }
    lineEndingIfNeeded();
    tag('<li>');
    setData('expectFirstItem');
    // “Hack” to prevent a line ending from showing up if the item is empty.
    setData('lastWasTag');
  }

  /**
   * @returns {undefined}
   */
  function onexitlistordered() {
    onexitlistitem();
    tightStack.pop();
    lineEnding();
    tag('</ol>');
  }

  /**
   * @returns {undefined}
   */
  function onexitlistunordered() {
    onexitlistitem();
    tightStack.pop();
    lineEnding();
    tag('</ul>');
  }

  /**
   * @returns {undefined}
   */
  function onexitlistitem() {
    if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {
      lineEndingIfNeeded();
    }
    tag('</li>');
    setData('slurpAllLineEndings');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterblockquote() {
<<<<<<< HEAD
    tightStack.push(false)
    lineEndingIfNeeded()
    tag('<blockquote>')
=======
    tightStack.push(false);
    lineEndingIfNeeded();
    tag('<blockquote>');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitblockquote() {
<<<<<<< HEAD
    tightStack.pop()
    lineEndingIfNeeded()
    tag('</blockquote>')
    setData('slurpAllLineEndings')
=======
    tightStack.pop();
    lineEndingIfNeeded();
    tag('</blockquote>');
    setData('slurpAllLineEndings');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterparagraph() {
    if (!tightStack[tightStack.length - 1]) {
<<<<<<< HEAD
      lineEndingIfNeeded()
      tag('<p>')
    }
    setData('slurpAllLineEndings')
=======
      lineEndingIfNeeded();
      tag('<p>');
    }
    setData('slurpAllLineEndings');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitparagraph() {
    if (tightStack[tightStack.length - 1]) {
<<<<<<< HEAD
      setData('slurpAllLineEndings', true)
    } else {
      tag('</p>')
=======
      setData('slurpAllLineEndings', true);
    } else {
      tag('</p>');
>>>>>>> 08f40ceb (Initial)
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onentercodefenced() {
<<<<<<< HEAD
    lineEndingIfNeeded()
    tag('<pre><code')
    setData('fencesCount', 0)
=======
    lineEndingIfNeeded();
    tag('<pre><code');
    setData('fencesCount', 0);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfenceinfo() {
<<<<<<< HEAD
    const value = resume()
    tag(' class="language-' + value + '"')
=======
    const value = resume();
    tag(' class="language-' + value + '"');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfence() {
<<<<<<< HEAD
    const count = getData('fencesCount') || 0
    if (!count) {
      tag('>')
      setData('slurpOneLineEnding', true)
    }
    setData('fencesCount', count + 1)
=======
    const count = getData('fencesCount') || 0;
    if (!count) {
      tag('>');
      setData('slurpOneLineEnding', true);
    }
    setData('fencesCount', count + 1);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onentercodeindented() {
<<<<<<< HEAD
    lineEndingIfNeeded()
    tag('<pre><code>')
=======
    lineEndingIfNeeded();
    tag('<pre><code>');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitflowcode() {
<<<<<<< HEAD
    const count = getData('fencesCount')
=======
    const count = getData('fencesCount');
>>>>>>> 08f40ceb (Initial)

    // One special case is if we are inside a container, and the fenced code was
    // not closed (meaning it runs to the end).
    // In that case, the following line ending, is considered *outside* the
    // fenced code and block quote by micromark, but CM wants to treat that
    // ending as part of the code.
<<<<<<< HEAD
    if (
      count !== undefined &&
      count < 2 &&
      data.tightStack.length > 0 &&
      !getData('lastWasTag')
    ) {
      lineEnding()
=======
    if (count !== undefined && count < 2 && data.tightStack.length > 0 && !getData('lastWasTag')) {
      lineEnding();
>>>>>>> 08f40ceb (Initial)
    }

    // But in most cases, it’s simpler: when we’ve seen some data, emit an extra
    // line ending when needed.
    if (getData('flowCodeSeenData')) {
<<<<<<< HEAD
      lineEndingIfNeeded()
    }
    tag('</code></pre>')
    if (count !== undefined && count < 2) lineEndingIfNeeded()
    setData('flowCodeSeenData')
    setData('fencesCount')
    setData('slurpOneLineEnding')
=======
      lineEndingIfNeeded();
    }
    tag('</code></pre>');
    if (count !== undefined && count < 2) lineEndingIfNeeded();
    setData('flowCodeSeenData');
    setData('fencesCount');
    setData('slurpOneLineEnding');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterimage() {
    mediaStack.push({
      image: true
<<<<<<< HEAD
    })
    tags = undefined // Disallow tags.
=======
    });
    tags = undefined; // Disallow tags.
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlink() {
<<<<<<< HEAD
    mediaStack.push({})
=======
    mediaStack.push({});
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitlabeltext(token) {
<<<<<<< HEAD
    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)
=======
    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitlabel() {
<<<<<<< HEAD
    mediaStack[mediaStack.length - 1].label = resume()
=======
    mediaStack[mediaStack.length - 1].label = resume();
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitreferencestring(token) {
<<<<<<< HEAD
    mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token)
=======
    mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterresource() {
<<<<<<< HEAD
    buffer() // We can have line endings in the resource, ignore them.
    mediaStack[mediaStack.length - 1].destination = ''
=======
    buffer(); // We can have line endings in the resource, ignore them.
    mediaStack[mediaStack.length - 1].destination = '';
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterresourcedestinationstring() {
<<<<<<< HEAD
    buffer()
    // Ignore encoding the result, as we’ll first percent encode the url and
    // encode manually after.
    setData('ignoreEncode', true)
=======
    buffer();
    // Ignore encoding the result, as we’ll first percent encode the url and
    // encode manually after.
    setData('ignoreEncode', true);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitresourcedestinationstring() {
<<<<<<< HEAD
    mediaStack[mediaStack.length - 1].destination = resume()
    setData('ignoreEncode')
=======
    mediaStack[mediaStack.length - 1].destination = resume();
    setData('ignoreEncode');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitresourcetitlestring() {
<<<<<<< HEAD
    mediaStack[mediaStack.length - 1].title = resume()
=======
    mediaStack[mediaStack.length - 1].title = resume();
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitmedia() {
<<<<<<< HEAD
    let index = mediaStack.length - 1 // Skip current.
    const media = mediaStack[index]
    const id = media.referenceId || media.labelId
    const context =
      media.destination === undefined
        ? definitions[normalizeIdentifier(id)]
        : media
    tags = true
    while (index--) {
      if (mediaStack[index].image) {
        tags = undefined
        break
      }
    }
    if (media.image) {
      tag(
        '<img src="' +
          sanitizeUri(
            context.destination,
            settings.allowDangerousProtocol ? undefined : protocolSrc
          ) +
          '" alt="'
      )
      raw(media.label)
      tag('"')
    } else {
      tag(
        '<a href="' +
          sanitizeUri(
            context.destination,
            settings.allowDangerousProtocol ? undefined : protocolHref
          ) +
          '"'
      )
    }
    tag(context.title ? ' title="' + context.title + '"' : '')
    if (media.image) {
      tag(' />')
    } else {
      tag('>')
      raw(media.label)
      tag('</a>')
    }
    mediaStack.pop()
=======
    let index = mediaStack.length - 1; // Skip current.
    const media = mediaStack[index];
    const id = media.referenceId || media.labelId;
    const context = media.destination === undefined ? definitions[normalizeIdentifier(id)] : media;
    tags = true;
    while (index--) {
      if (mediaStack[index].image) {
        tags = undefined;
        break;
      }
    }
    if (media.image) {
      tag('<img src="' + sanitizeUri(context.destination, settings.allowDangerousProtocol ? undefined : protocolSource) + '" alt="');
      raw(media.label);
      tag('"');
    } else {
      tag('<a href="' + sanitizeUri(context.destination, settings.allowDangerousProtocol ? undefined : protocolHref) + '"');
    }
    tag(context.title ? ' title="' + context.title + '"' : '');
    if (media.image) {
      tag(' />');
    } else {
      tag('>');
      raw(media.label);
      tag('</a>');
    }
    mediaStack.pop();
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterdefinition() {
<<<<<<< HEAD
    buffer()
    mediaStack.push({})
=======
    buffer();
    mediaStack.push({});
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitionlabelstring(token) {
    // Discard label, use the source content instead.
<<<<<<< HEAD
    resume()
    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)
=======
    resume();
    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterdefinitiondestinationstring() {
<<<<<<< HEAD
    buffer()
    setData('ignoreEncode', true)
=======
    buffer();
    setData('ignoreEncode', true);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitiondestinationstring() {
<<<<<<< HEAD
    mediaStack[mediaStack.length - 1].destination = resume()
    setData('ignoreEncode')
=======
    mediaStack[mediaStack.length - 1].destination = resume();
    setData('ignoreEncode');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitiontitlestring() {
<<<<<<< HEAD
    mediaStack[mediaStack.length - 1].title = resume()
=======
    mediaStack[mediaStack.length - 1].title = resume();
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinition() {
<<<<<<< HEAD
    const media = mediaStack[mediaStack.length - 1]
    const id = normalizeIdentifier(media.labelId)
    resume()
    if (!hasOwnProperty.call(definitions, id)) {
      definitions[id] = mediaStack[mediaStack.length - 1]
    }
    mediaStack.pop()
=======
    const media = mediaStack[mediaStack.length - 1];
    const id = normalizeIdentifier(media.labelId);
    resume();
    if (!hasOwnProperty.call(definitions, id)) {
      definitions[id] = mediaStack[mediaStack.length - 1];
    }
    mediaStack.pop();
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onentercontent() {
<<<<<<< HEAD
    setData('slurpAllLineEndings', true)
=======
    setData('slurpAllLineEndings', true);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitatxheadingsequence(token) {
    // Exit for further sequences.
<<<<<<< HEAD
    if (getData('headingRank')) return
    setData('headingRank', this.sliceSerialize(token).length)
    lineEndingIfNeeded()
    tag('<h' + getData('headingRank') + '>')
=======
    if (getData('headingRank')) return;
    setData('headingRank', this.sliceSerialize(token).length);
    lineEndingIfNeeded();
    tag('<h' + getData('headingRank') + '>');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onentersetextheading() {
<<<<<<< HEAD
    buffer()
    setData('slurpAllLineEndings')
=======
    buffer();
    setData('slurpAllLineEndings');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheadingtext() {
<<<<<<< HEAD
    setData('slurpAllLineEndings', true)
=======
    setData('slurpAllLineEndings', true);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitatxheading() {
<<<<<<< HEAD
    tag('</h' + getData('headingRank') + '>')
    setData('headingRank')
=======
    tag('</h' + getData('headingRank') + '>');
    setData('headingRank');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheadinglinesequence(token) {
<<<<<<< HEAD
    setData(
      'headingRank',
      this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2
    )
=======
    setData('headingRank', this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheading() {
<<<<<<< HEAD
    const value = resume()
    lineEndingIfNeeded()
    tag('<h' + getData('headingRank') + '>')
    raw(value)
    tag('</h' + getData('headingRank') + '>')
    setData('slurpAllLineEndings')
    setData('headingRank')
=======
    const value = resume();
    lineEndingIfNeeded();
    tag('<h' + getData('headingRank') + '>');
    raw(value);
    tag('</h' + getData('headingRank') + '>');
    setData('slurpAllLineEndings');
    setData('headingRank');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdata(token) {
<<<<<<< HEAD
    raw(encode(this.sliceSerialize(token)))
=======
    raw(encode(this.sliceSerialize(token)));
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitlineending(token) {
    if (getData('slurpAllLineEndings')) {
<<<<<<< HEAD
      return
    }
    if (getData('slurpOneLineEnding')) {
      setData('slurpOneLineEnding')
      return
    }
    if (getData('inCodeText')) {
      raw(' ')
      return
    }
    raw(encode(this.sliceSerialize(token)))
=======
      return;
    }
    if (getData('slurpOneLineEnding')) {
      setData('slurpOneLineEnding');
      return;
    }
    if (getData('inCodeText')) {
      raw(' ');
      return;
    }
    raw(encode(this.sliceSerialize(token)));
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodeflowvalue(token) {
<<<<<<< HEAD
    raw(encode(this.sliceSerialize(token)))
    setData('flowCodeSeenData', true)
=======
    raw(encode(this.sliceSerialize(token)));
    setData('flowCodeSeenData', true);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexithardbreak() {
<<<<<<< HEAD
    tag('<br />')
  }
  function onenterhtmlflow() {
    lineEndingIfNeeded()
    onenterhtml()
  }
  function onexithtml() {
    setData('ignoreEncode')
  }
  function onenterhtml() {
    if (settings.allowDangerousHtml) {
      setData('ignoreEncode', true)
    }
  }
  function onenteremphasis() {
    tag('<em>')
  }
  function onenterstrong() {
    tag('<strong>')
  }
  function onentercodetext() {
    setData('inCodeText', true)
    tag('<code>')
  }
  function onexitcodetext() {
    setData('inCodeText')
    tag('</code>')
  }
  function onexitemphasis() {
    tag('</em>')
  }
  function onexitstrong() {
    tag('</strong>')
  }
  function onexitthematicbreak() {
    lineEndingIfNeeded()
    tag('<hr />')
=======
    tag('<br />');
  }

  /**
   * @returns {undefined}
   */
  function onenterhtmlflow() {
    lineEndingIfNeeded();
    onenterhtml();
  }

  /**
   * @returns {undefined}
   */
  function onexithtml() {
    setData('ignoreEncode');
  }

  /**
   * @returns {undefined}
   */
  function onenterhtml() {
    if (settings.allowDangerousHtml) {
      setData('ignoreEncode', true);
    }
  }

  /**
   * @returns {undefined}
   */
  function onenteremphasis() {
    tag('<em>');
  }

  /**
   * @returns {undefined}
   */
  function onenterstrong() {
    tag('<strong>');
  }

  /**
   * @returns {undefined}
   */
  function onentercodetext() {
    setData('inCodeText', true);
    tag('<code>');
  }

  /**
   * @returns {undefined}
   */
  function onexitcodetext() {
    setData('inCodeText');
    tag('</code>');
  }

  /**
   * @returns {undefined}
   */
  function onexitemphasis() {
    tag('</em>');
  }

  /**
   * @returns {undefined}
   */
  function onexitstrong() {
    tag('</strong>');
  }

  /**
   * @returns {undefined}
   */
  function onexitthematicbreak() {
    lineEndingIfNeeded();
    tag('<hr />');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @param {Token} token
<<<<<<< HEAD
   */
  function onexitcharacterreferencemarker(token) {
    setData('characterReferenceType', token.type)
=======
   * @returns {undefined}
   */
  function onexitcharacterreferencemarker(token) {
    setData('characterReferenceType', token.type);
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcharacterreferencevalue(token) {
<<<<<<< HEAD
    let value = this.sliceSerialize(token)

    // @ts-expect-error `decodeNamedCharacterReference` can return false for
    // invalid named character references, but everything we’ve tokenized is
    // valid.
    value = getData('characterReferenceType')
      ? decodeNumericCharacterReference(
          value,
          getData('characterReferenceType') ===
            'characterReferenceMarkerNumeric'
            ? 10
            : 16
        )
      : decodeNamedCharacterReference(value)
    raw(encode(value))
    setData('characterReferenceType')
=======
    const value = this.sliceSerialize(token);
    const decoded = getData('characterReferenceType') ? decodeNumericCharacterReference(value, getData('characterReferenceType') === "characterReferenceMarkerNumeric" ? 10 : 16) : decodeNamedCharacterReference(value);

    // `decodeNamedCharacterReference` can return `false` for invalid named
    // character references,
    // but everything we’ve tokenized is valid.
    raw(encode(/** @type {string} */decoded));
    setData('characterReferenceType');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitautolinkprotocol(token) {
<<<<<<< HEAD
    const uri = this.sliceSerialize(token)
    tag(
      '<a href="' +
        sanitizeUri(
          uri,
          settings.allowDangerousProtocol ? undefined : protocolHref
        ) +
        '">'
    )
    raw(encode(uri))
    tag('</a>')
=======
    const uri = this.sliceSerialize(token);
    tag('<a href="' + sanitizeUri(uri, settings.allowDangerousProtocol ? undefined : protocolHref) + '">');
    raw(encode(uri));
    tag('</a>');
>>>>>>> 08f40ceb (Initial)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitautolinkemail(token) {
<<<<<<< HEAD
    const uri = this.sliceSerialize(token)
    tag('<a href="' + sanitizeUri('mailto:' + uri) + '">')
    raw(encode(uri))
    tag('</a>')
  }
}
=======
    const uri = this.sliceSerialize(token);
    tag('<a href="' + sanitizeUri('mailto:' + uri) + '">');
    raw(encode(uri));
    tag('</a>');
  }
}
>>>>>>> 08f40ceb (Initial)
