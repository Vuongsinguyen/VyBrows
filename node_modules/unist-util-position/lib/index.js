/**
<<<<<<< HEAD
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Point} Point
=======
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Point} Point
 * @typedef {import('unist').Position} Position
>>>>>>> 08f40ceb (Initial)
 */

/**
 * @typedef NodeLike
 * @property {string} type
 * @property {PositionLike | null | undefined} [position]
 *
 * @typedef PositionLike
 * @property {PointLike | null | undefined} [start]
 * @property {PointLike | null | undefined} [end]
 *
 * @typedef PointLike
 * @property {number | null | undefined} [line]
 * @property {number | null | undefined} [column]
 * @property {number | null | undefined} [offset]
 */

/**
<<<<<<< HEAD
 * Get the starting point of `node`.
 *
 * @param node
 *   Node.
 * @returns
 *   Point.
 */
export const pointStart = point('start')

/**
=======
>>>>>>> 08f40ceb (Initial)
 * Get the ending point of `node`.
 *
 * @param node
 *   Node.
 * @returns
 *   Point.
 */
export const pointEnd = point('end')

/**
<<<<<<< HEAD
 * Get the positional info of `node`.
 *
 * @param {NodeLike | Node | null | undefined} [node]
 *   Node.
 * @returns {Position}
 *   Position.
 */
export function position(node) {
  return {start: pointStart(node), end: pointEnd(node)}
}
=======
 * Get the starting point of `node`.
 *
 * @param node
 *   Node.
 * @returns
 *   Point.
 */
export const pointStart = point('start')
>>>>>>> 08f40ceb (Initial)

/**
 * Get the positional info of `node`.
 *
<<<<<<< HEAD
 * @param {'start' | 'end'} type
=======
 * @param {'end' | 'start'} type
>>>>>>> 08f40ceb (Initial)
 *   Side.
 * @returns
 *   Getter.
 */
function point(type) {
  return point

  /**
   * Get the point info of `node` at a bound side.
   *
<<<<<<< HEAD
   * @param {NodeLike | Node | null | undefined} [node]
   * @returns {Point}
=======
   * @param {Node | NodeLike | null | undefined} [node]
   * @returns {Point | undefined}
>>>>>>> 08f40ceb (Initial)
   */
  function point(node) {
    const point = (node && node.position && node.position[type]) || {}

<<<<<<< HEAD
    // To do: next major: donâ€™t return points when invalid.
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: point.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: point.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: point.offset > -1 ? point.offset : null
    }
  }
}
=======
    if (
      typeof point.line === 'number' &&
      point.line > 0 &&
      typeof point.column === 'number' &&
      point.column > 0
    ) {
      return {
        line: point.line,
        column: point.column,
        offset:
          typeof point.offset === 'number' && point.offset > -1
            ? point.offset
            : undefined
      }
    }
  }
}

/**
 * Get the positional info of `node`.
 *
 * @param {Node | NodeLike | null | undefined} [node]
 *   Node.
 * @returns {Position | undefined}
 *   Position.
 */
export function position(node) {
  const start = pointStart(node)
  const end = pointEnd(node)

  if (start && end) {
    return {start, end}
  }
}
>>>>>>> 08f40ceb (Initial)
