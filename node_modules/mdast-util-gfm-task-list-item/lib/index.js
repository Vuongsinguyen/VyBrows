/**
<<<<<<< HEAD
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('mdast').Parent} Parent
 * @typedef {import('mdast').Root} Root
=======
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
>>>>>>> 08f40ceb (Initial)
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 */

<<<<<<< HEAD
/**
 * @typedef {Extract<Root | Content, Parent>} Parents
 */

import {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'
import {track} from 'mdast-util-to-markdown/lib/util/track.js'

// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use
// `track` from `state`.
// To do: next major: replace exports with functions.
// To do: next major: use `defaulthandlers.listItem`.

/**
 * Extension for `mdast-util-from-markdown` to enable GFM task list items.
 *
 * @type {FromMarkdownExtension}
 */
export const gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
=======
import {ok as assert} from 'devlop'
import {defaultHandlers} from 'mdast-util-to-markdown'

/**
 * Create an extension for `mdast-util-from-markdown` to enable GFM task
 * list items in markdown.
 *
 * @returns {FromMarkdownExtension}
 *   Extension for `mdast-util-from-markdown` to enable GFM task list items.
 */
export function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
>>>>>>> 08f40ceb (Initial)
  }
}

/**
<<<<<<< HEAD
 * Extension for `mdast-util-to-markdown` to enable GFM task list items.
 *
 * @type {ToMarkdownExtension}
 */
export const gfmTaskListItemToMarkdown = {
  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],
  handlers: {listItem: listItemWithTaskListItem}
=======
 * Create an extension for `mdast-util-to-markdown` to enable GFM task list
 * items in markdown.
 *
 * @returns {ToMarkdownExtension}
 *   Extension for `mdast-util-to-markdown` to enable GFM task list items.
 */
export function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],
    handlers: {listItem: listItemWithTaskListItem}
  }
>>>>>>> 08f40ceb (Initial)
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitCheck(token) {
<<<<<<< HEAD
  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])
  // We’re always in a paragraph, in a list item.
=======
  // We’re always in a paragraph, in a list item.
  const node = this.stack[this.stack.length - 2]
  assert(node.type === 'listItem')
>>>>>>> 08f40ceb (Initial)
  node.checked = token.type === 'taskListCheckValueChecked'
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitParagraphWithTaskListItem(token) {
<<<<<<< HEAD
  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])
=======
  const parent = this.stack[this.stack.length - 2]
>>>>>>> 08f40ceb (Initial)

  if (
    parent &&
    parent.type === 'listItem' &&
    typeof parent.checked === 'boolean'
  ) {
<<<<<<< HEAD
    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])
=======
    const node = this.stack[this.stack.length - 1]
    assert(node.type === 'paragraph')
>>>>>>> 08f40ceb (Initial)
    const head = node.children[0]

    if (head && head.type === 'text') {
      const siblings = parent.children
      let index = -1
      /** @type {Paragraph | undefined} */
      let firstParaghraph

      while (++index < siblings.length) {
        const sibling = siblings[index]
        if (sibling.type === 'paragraph') {
          firstParaghraph = sibling
          break
        }
      }

      if (firstParaghraph === node) {
        // Must start with a space or a tab.
        head.value = head.value.slice(1)

        if (head.value.length === 0) {
          node.children.shift()
        } else if (
          node.position &&
          head.position &&
          typeof head.position.start.offset === 'number'
        ) {
          head.position.start.column++
          head.position.start.offset++
          node.position.start = Object.assign({}, head.position.start)
        }
      }
    }
  }

  this.exit(token)
}

/**
 * @type {ToMarkdownHandle}
 * @param {ListItem} node
 */
<<<<<<< HEAD
function listItemWithTaskListItem(node, parent, context, safeOptions) {
=======
function listItemWithTaskListItem(node, parent, state, info) {
>>>>>>> 08f40ceb (Initial)
  const head = node.children[0]
  const checkable =
    typeof node.checked === 'boolean' && head && head.type === 'paragraph'
  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '
<<<<<<< HEAD
  const tracker = track(safeOptions)
=======
  const tracker = state.createTracker(info)
>>>>>>> 08f40ceb (Initial)

  if (checkable) {
    tracker.move(checkbox)
  }

<<<<<<< HEAD
  let value = listItem(node, parent, context, {
    ...safeOptions,
=======
  let value = defaultHandlers.listItem(node, parent, state, {
    ...info,
>>>>>>> 08f40ceb (Initial)
    ...tracker.current()
  })

  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check)
  }

  return value

  /**
   * @param {string} $0
   * @returns {string}
   */
  function check($0) {
    return $0 + checkbox
  }
}
