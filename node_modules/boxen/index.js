import process from 'node:process';
import stringWidth from 'string-width';
import chalk from 'chalk';
import widestLine from 'widest-line';
import cliBoxes from 'cli-boxes';
import camelCase from 'camelcase';
import ansiAlign from 'ansi-align';
import wrapAnsi from 'wrap-ansi';

const NEWLINE = '\n';
const PAD = ' ';
<<<<<<< HEAD
const BORDERS_WIDTH = 2;
=======
const NONE = 'none';
>>>>>>> 08f40ceb (Initial)

const terminalColumns = () => {
	const {env, stdout, stderr} = process;

<<<<<<< HEAD
	if (stdout && stdout.columns) {
		return stdout.columns;
	}

	if (stderr && stderr.columns) {
=======
	if (stdout?.columns) {
		return stdout.columns;
	}

	if (stderr?.columns) {
>>>>>>> 08f40ceb (Initial)
		return stderr.columns;
	}

	if (env.COLUMNS) {
		return Number.parseInt(env.COLUMNS, 10);
	}

	return 80;
};

const getObject = detail => typeof detail === 'number' ? {
	top: detail,
	right: detail * 3,
	bottom: detail,
	left: detail * 3,
} : {
	top: 0,
	right: 0,
	bottom: 0,
	left: 0,
	...detail,
};

<<<<<<< HEAD
=======
const getBorderWidth = borderStyle => borderStyle === NONE ? 0 : 2;

>>>>>>> 08f40ceb (Initial)
const getBorderChars = borderStyle => {
	const sides = [
		'topLeft',
		'topRight',
		'bottomRight',
		'bottomLeft',
		'left',
		'right',
		'top',
		'bottom',
	];

	let characters;

<<<<<<< HEAD
=======
	// Create empty border style
	if (borderStyle === NONE) {
		borderStyle = {};
		for (const side of sides) {
			borderStyle[side] = '';
		}
	}

>>>>>>> 08f40ceb (Initial)
	if (typeof borderStyle === 'string') {
		characters = cliBoxes[borderStyle];

		if (!characters) {
			throw new TypeError(`Invalid border style: ${borderStyle}`);
		}
	} else {
		// Ensure retro-compatibility
<<<<<<< HEAD
		if (borderStyle.vertical && typeof borderStyle.vertical === 'string') {
=======
		if (typeof borderStyle?.vertical === 'string') {
>>>>>>> 08f40ceb (Initial)
			borderStyle.left = borderStyle.vertical;
			borderStyle.right = borderStyle.vertical;
		}

		// Ensure retro-compatibility
<<<<<<< HEAD
		if (borderStyle.horizontal && typeof borderStyle.horizontal === 'string') {
=======
		if (typeof borderStyle?.horizontal === 'string') {
>>>>>>> 08f40ceb (Initial)
			borderStyle.top = borderStyle.horizontal;
			borderStyle.bottom = borderStyle.horizontal;
		}

		for (const side of sides) {
<<<<<<< HEAD
			if (!borderStyle[side] || typeof borderStyle[side] !== 'string') {
=======
			if (borderStyle[side] === null || typeof borderStyle[side] !== 'string') {
>>>>>>> 08f40ceb (Initial)
				throw new TypeError(`Invalid border style: ${side}`);
			}
		}

		characters = borderStyle;
	}

	return characters;
};

<<<<<<< HEAD
const makeTitle = (text, horizontal, alignement) => {
=======
const makeTitle = (text, horizontal, alignment) => {
>>>>>>> 08f40ceb (Initial)
	let title = '';

	const textWidth = stringWidth(text);

<<<<<<< HEAD
	switch (alignement) {
		case 'left':
			title = text + horizontal.slice(textWidth);
			break;
		case 'right':
			title = horizontal.slice(textWidth) + text;
			break;
		default:
=======
	switch (alignment) {
		case 'left': {
			title = text + horizontal.slice(textWidth);
			break;
		}

		case 'right': {
			title = horizontal.slice(textWidth) + text;
			break;
		}

		default: {
>>>>>>> 08f40ceb (Initial)
			horizontal = horizontal.slice(textWidth);

			if (horizontal.length % 2 === 1) { // This is needed in case the length is odd
				horizontal = horizontal.slice(Math.floor(horizontal.length / 2));
				title = horizontal.slice(1) + text + horizontal; // We reduce the left part of one character to avoid the bar to go beyond its limit
			} else {
				horizontal = horizontal.slice(horizontal.length / 2);
				title = horizontal + text + horizontal;
			}

			break;
<<<<<<< HEAD
=======
		}
>>>>>>> 08f40ceb (Initial)
	}

	return title;
};

<<<<<<< HEAD
const makeContentText = (text, padding, columns, align) => {
	text = ansiAlign(text, {align});
	let lines = text.split(NEWLINE);
	const textWidth = widestLine(text);

	const max = columns - padding.left - padding.right;
=======
const makeContentText = (text, {padding, width, textAlignment, height}) => {
	text = ansiAlign(text, {align: textAlignment});
	let lines = text.split(NEWLINE);
	const textWidth = widestLine(text);

	const max = width - padding.left - padding.right;
>>>>>>> 08f40ceb (Initial)

	if (textWidth > max) {
		const newLines = [];
		for (const line of lines) {
			const createdLines = wrapAnsi(line, max, {hard: true});
<<<<<<< HEAD
			const alignedLines = ansiAlign(createdLines, {align});
=======
			const alignedLines = ansiAlign(createdLines, {align: textAlignment});
>>>>>>> 08f40ceb (Initial)
			const alignedLinesArray = alignedLines.split('\n');
			const longestLength = Math.max(...alignedLinesArray.map(s => stringWidth(s)));

			for (const alignedLine of alignedLinesArray) {
				let paddedLine;
<<<<<<< HEAD
				switch (align) {
					case 'center':
						paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
						break;
					case 'right':
						paddedLine = PAD.repeat(max - longestLength) + alignedLine;
						break;
					default:
						paddedLine = alignedLine;
						break;
=======
				switch (textAlignment) {
					case 'center': {
						paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
						break;
					}

					case 'right': {
						paddedLine = PAD.repeat(max - longestLength) + alignedLine;
						break;
					}

					default: {
						paddedLine = alignedLine;
						break;
					}
>>>>>>> 08f40ceb (Initial)
				}

				newLines.push(paddedLine);
			}
		}

		lines = newLines;
	}

<<<<<<< HEAD
	if (align === 'center' && textWidth < max) {
		lines = lines.map(line => PAD.repeat((max - textWidth) / 2) + line);
	} else if (align === 'right' && textWidth < max) {
=======
	if (textAlignment === 'center' && textWidth < max) {
		lines = lines.map(line => PAD.repeat((max - textWidth) / 2) + line);
	} else if (textAlignment === 'right' && textWidth < max) {
>>>>>>> 08f40ceb (Initial)
		lines = lines.map(line => PAD.repeat(max - textWidth) + line);
	}

	const paddingLeft = PAD.repeat(padding.left);
	const paddingRight = PAD.repeat(padding.right);

<<<<<<< HEAD
	lines = lines.map(line => paddingLeft + line + paddingRight);

	lines = lines.map(line => {
		if (columns - stringWidth(line) > 0) {
			switch (align) {
				case 'center':
					return line + PAD.repeat(columns - stringWidth(line));
				case 'right':
					return line + PAD.repeat(columns - stringWidth(line));
				default:
					return line + PAD.repeat(columns - stringWidth(line));
			}
		}

		return line;
	});

	if (padding.top > 0) {
		lines = [...Array.from({length: padding.top}).fill(PAD.repeat(columns)), ...lines];
	}

	if (padding.bottom > 0) {
		lines = [...lines, ...Array.from({length: padding.bottom}).fill(PAD.repeat(columns))];
=======
	lines = lines.map(line => {
		const newLine = paddingLeft + line + paddingRight;

		return newLine + PAD.repeat(width - stringWidth(newLine));
	});

	if (padding.top > 0) {
		lines = [...Array.from({length: padding.top}).fill(PAD.repeat(width)), ...lines];
	}

	if (padding.bottom > 0) {
		lines = [...lines, ...Array.from({length: padding.bottom}).fill(PAD.repeat(width))];
	}

	if (height && lines.length > height) {
		lines = lines.slice(0, height);
	} else if (height && lines.length < height) {
		lines = [...lines, ...Array.from({length: height - lines.length}).fill(PAD.repeat(width))];
>>>>>>> 08f40ceb (Initial)
	}

	return lines.join(NEWLINE);
};

const boxContent = (content, contentWidth, options) => {
	const colorizeBorder = border => {
<<<<<<< HEAD
		const newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;
		return options.dimBorder ? chalk.dim(newBorder) : newBorder;
	};

	const colorizeContent = content => options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;
=======
		const newBorder = options.borderColor ? getColorFunction(options.borderColor)(border) : border;
		return options.dimBorder ? chalk.dim(newBorder) : newBorder;
	};

	const colorizeContent = content => options.backgroundColor ? getBGColorFunction(options.backgroundColor)(content) : content;
>>>>>>> 08f40ceb (Initial)

	const chars = getBorderChars(options.borderStyle);
	const columns = terminalColumns();
	let marginLeft = PAD.repeat(options.margin.left);

	if (options.float === 'center') {
<<<<<<< HEAD
		const marginWidth = Math.max((columns - contentWidth - BORDERS_WIDTH) / 2, 0);
		marginLeft = PAD.repeat(marginWidth);
	} else if (options.float === 'right') {
		const marginWidth = Math.max(columns - contentWidth - options.margin.right - BORDERS_WIDTH, 0);
		marginLeft = PAD.repeat(marginWidth);
	}

	const top = colorizeBorder(NEWLINE.repeat(options.margin.top) + marginLeft + chars.topLeft + (options.title ? makeTitle(options.title, chars.top.repeat(contentWidth), options.titleAlignment) : chars.top.repeat(contentWidth)) + chars.topRight);
	const bottom = colorizeBorder(marginLeft + chars.bottomLeft + chars.bottom.repeat(contentWidth) + chars.bottomRight + NEWLINE.repeat(options.margin.bottom));

	const LINE_SEPARATOR = (contentWidth + BORDERS_WIDTH + options.margin.left >= columns) ? '' : NEWLINE;

	const lines = content.split(NEWLINE);

	const middle = lines.map(line => marginLeft + colorizeBorder(chars.left) + colorizeContent(line) + colorizeBorder(chars.right)).join(LINE_SEPARATOR);

	return top + LINE_SEPARATOR + middle + LINE_SEPARATOR + bottom;
};

const determineDimensions = (text, options) => {
	const widthOverride = options.width !== undefined;
	const columns = terminalColumns();
	const maxWidth = columns - options.margin.left - options.margin.right - BORDERS_WIDTH;

	// If width is provided, make sure it's not below 1
	if (options.width) {
		options.width = Math.max(1, options.width - BORDERS_WIDTH);
	}

	const widest = widestLine(wrapAnsi(text, columns - BORDERS_WIDTH, {hard: true, trim: false})) + options.padding.left + options.padding.right;
=======
		const marginWidth = Math.max((columns - contentWidth - getBorderWidth(options.borderStyle)) / 2, 0);
		marginLeft = PAD.repeat(marginWidth);
	} else if (options.float === 'right') {
		const marginWidth = Math.max(columns - contentWidth - options.margin.right - getBorderWidth(options.borderStyle), 0);
		marginLeft = PAD.repeat(marginWidth);
	}

	let result = '';

	if (options.margin.top) {
		result += NEWLINE.repeat(options.margin.top);
	}

	if (options.borderStyle !== NONE || options.title) {
		result += colorizeBorder(marginLeft + chars.topLeft + (options.title ? makeTitle(options.title, chars.top.repeat(contentWidth), options.titleAlignment) : chars.top.repeat(contentWidth)) + chars.topRight) + NEWLINE;
	}

	const lines = content.split(NEWLINE);

	result += lines.map(line => marginLeft + colorizeBorder(chars.left) + colorizeContent(line) + colorizeBorder(chars.right)).join(NEWLINE);

	if (options.borderStyle !== NONE) {
		result += NEWLINE + colorizeBorder(marginLeft + chars.bottomLeft + chars.bottom.repeat(contentWidth) + chars.bottomRight);
	}

	if (options.margin.bottom) {
		result += NEWLINE.repeat(options.margin.bottom);
	}

	return result;
};

const sanitizeOptions = options => {
	// If fullscreen is enabled, max-out unspecified width/height
	if (options.fullscreen && process?.stdout) {
		let newDimensions = [process.stdout.columns, process.stdout.rows];

		if (typeof options.fullscreen === 'function') {
			newDimensions = options.fullscreen(...newDimensions);
		}

		options.width ||= newDimensions[0];

		options.height ||= newDimensions[1];
	}

	// If width is provided, make sure it's not below 1
	options.width &&= Math.max(1, options.width - getBorderWidth(options.borderStyle));

	// If height is provided, make sure it's not below 1
	options.height &&= Math.max(1, options.height - getBorderWidth(options.borderStyle));

	return options;
};

const formatTitle = (title, borderStyle) => borderStyle === NONE ? title : ` ${title} `;

const determineDimensions = (text, options) => {
	options = sanitizeOptions(options);
	const widthOverride = options.width !== undefined;
	const columns = terminalColumns();
	const borderWidth = getBorderWidth(options.borderStyle);
	const maxWidth = columns - options.margin.left - options.margin.right - borderWidth;

	const widest = widestLine(wrapAnsi(text, columns - borderWidth, {hard: true, trim: false})) + options.padding.left + options.padding.right;
>>>>>>> 08f40ceb (Initial)

	// If title and width are provided, title adheres to fixed width
	if (options.title && widthOverride) {
		options.title = options.title.slice(0, Math.max(0, options.width - 2));
<<<<<<< HEAD
		if (options.title) {
			options.title = ` ${options.title} `;
		}
=======
		options.title &&= formatTitle(options.title, options.borderStyle);
>>>>>>> 08f40ceb (Initial)
	} else if (options.title) {
		options.title = options.title.slice(0, Math.max(0, maxWidth - 2));

		// Recheck if title isn't empty now
		if (options.title) {
<<<<<<< HEAD
			options.title = ` ${options.title} `;
=======
			options.title = formatTitle(options.title, options.borderStyle);
>>>>>>> 08f40ceb (Initial)
			// If the title is larger than content, box adheres to title width
			if (stringWidth(options.title) > widest) {
				options.width = stringWidth(options.title);
			}
		}
	}

	// If fixed width is provided, use it or content width as reference
<<<<<<< HEAD
	options.width = options.width ? options.width : widest;
=======
	options.width ||= widest;
>>>>>>> 08f40ceb (Initial)

	if (!widthOverride) {
		if ((options.margin.left && options.margin.right) && options.width > maxWidth) {
			// Let's assume we have margins: left = 3, right = 5, in total = 8
<<<<<<< HEAD
			const spaceForMargins = columns - options.width - BORDERS_WIDTH;
=======
			const spaceForMargins = columns - options.width - borderWidth;
>>>>>>> 08f40ceb (Initial)
			// Let's assume we have space = 4
			const multiplier = spaceForMargins / (options.margin.left + options.margin.right);
			// Here: multiplier = 4/8 = 0.5
			options.margin.left = Math.max(0, Math.floor(options.margin.left * multiplier));
			options.margin.right = Math.max(0, Math.floor(options.margin.right * multiplier));
			// Left: 3 * 0.5 = 1.5 -> 1
			// Right: 6 * 0.5 = 3
		}

		// Re-cap width considering the margins after shrinking
<<<<<<< HEAD
		options.width = Math.min(options.width, columns - BORDERS_WIDTH - options.margin.left - options.margin.right);
=======
		options.width = Math.min(options.width, columns - borderWidth - options.margin.left - options.margin.right);
>>>>>>> 08f40ceb (Initial)
	}

	// Prevent padding overflow
	if (options.width - (options.padding.left + options.padding.right) <= 0) {
		options.padding.left = 0;
		options.padding.right = 0;
	}

<<<<<<< HEAD
=======
	if (options.height && options.height - (options.padding.top + options.padding.bottom) <= 0) {
		options.padding.top = 0;
		options.padding.bottom = 0;
	}

>>>>>>> 08f40ceb (Initial)
	return options;
};

const isHex = color => color.match(/^#(?:[0-f]{3}){1,2}$/i);
<<<<<<< HEAD
const isColorValid = color => typeof color === 'string' && ((chalk[color]) || isHex(color));
const getColorFn = color => isHex(color) ? chalk.hex(color) : chalk[color];
const getBGColorFn = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];
=======
const isColorValid = color => typeof color === 'string' && (chalk[color] ?? isHex(color));
const getColorFunction = color => isHex(color) ? chalk.hex(color) : chalk[color];
const getBGColorFunction = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];
>>>>>>> 08f40ceb (Initial)

export default function boxen(text, options) {
	options = {
		padding: 0,
		borderStyle: 'single',
		dimBorder: false,
		textAlignment: 'left',
		float: 'left',
		titleAlignment: 'left',
		...options,
	};

	// This option is deprecated
	if (options.align) {
		options.textAlignment = options.align;
	}

	if (options.borderColor && !isColorValid(options.borderColor)) {
		throw new Error(`${options.borderColor} is not a valid borderColor`);
	}

	if (options.backgroundColor && !isColorValid(options.backgroundColor)) {
		throw new Error(`${options.backgroundColor} is not a valid backgroundColor`);
	}

	options.padding = getObject(options.padding);
	options.margin = getObject(options.margin);

	options = determineDimensions(text, options);

<<<<<<< HEAD
	text = makeContentText(text, options.padding, options.width, options.textAlignment);
=======
	text = makeContentText(text, options);
>>>>>>> 08f40ceb (Initial)

	return boxContent(text, options.width, options);
}

<<<<<<< HEAD
export const _borderStyles = cliBoxes;
=======
export {default as _borderStyles} from 'cli-boxes';
>>>>>>> 08f40ceb (Initial)
