/**
<<<<<<< HEAD
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').Definition} Definition
 */

/**
 * @typedef {Root | Content} Node
 *
 * @callback GetDefinition
 *   Get a definition by identifier.
 * @param {string | null | undefined} [identifier]
 *   Identifier of definition.
 * @returns {Definition | null}
=======
 * @typedef {import('mdast').Definition} Definition
 * @typedef {import('mdast').Nodes} Nodes
 */

/**
 * @callback GetDefinition
 *   Get a definition by identifier.
 * @param {string | null | undefined} [identifier]
 *   Identifier of definition (optional).
 * @returns {Definition | undefined}
>>>>>>> 08f40ceb (Initial)
 *   Definition corresponding to `identifier` or `null`.
 */

import {visit} from 'unist-util-visit'

<<<<<<< HEAD
const own = {}.hasOwnProperty

=======
>>>>>>> 08f40ceb (Initial)
/**
 * Find definitions in `tree`.
 *
 * Uses CommonMark precedence, which means that earlier definitions are
 * preferred over duplicate later definitions.
 *
<<<<<<< HEAD
 * @param {Node} tree
=======
 * @param {Nodes} tree
>>>>>>> 08f40ceb (Initial)
 *   Tree to check.
 * @returns {GetDefinition}
 *   Getter.
 */
export function definitions(tree) {
<<<<<<< HEAD
  /** @type {Record<string, Definition>} */
  const cache = Object.create(null)
=======
  /** @type {Map<string, Definition>} */
  const cache = new Map()
>>>>>>> 08f40ceb (Initial)

  if (!tree || !tree.type) {
    throw new Error('mdast-util-definitions expected node')
  }

<<<<<<< HEAD
  visit(tree, 'definition', (definition) => {
    const id = clean(definition.identifier)
    if (id && !own.call(cache, id)) {
      cache[id] = definition
=======
  visit(tree, 'definition', function (definition) {
    const id = clean(definition.identifier)
    if (id && !cache.get(id)) {
      cache.set(id, definition)
>>>>>>> 08f40ceb (Initial)
    }
  })

  return definition

  /** @type {GetDefinition} */
  function definition(identifier) {
    const id = clean(identifier)
<<<<<<< HEAD
    // To do: next major: return `undefined` when not found.
    return id && own.call(cache, id) ? cache[id] : null
=======
    return cache.get(id)
>>>>>>> 08f40ceb (Initial)
  }
}

/**
 * @param {string | null | undefined} [value]
 * @returns {string}
 */
function clean(value) {
  return String(value || '').toUpperCase()
}
