/**
<<<<<<< HEAD
 * @typedef {import('nlcst').Content} Content
 * @typedef {import('nlcst').Root} Root
 */

=======
 * @typedef {import('nlcst').Nodes} Nodes
 */

/** @type {Readonly<Array<Nodes>>} */
const emptyNodes = []

>>>>>>> 08f40ceb (Initial)
/**
 * Get the text content of a node or list of nodes.
 *
 * Prefers the nodeâ€™s plain-text fields, otherwise serializes its children, and
 * if the given value is an array, serialize the nodes in it.
 *
<<<<<<< HEAD
 * @param {Root | Content | Array<Content>} value
 *   Node or list of nodes to serialize.
 * @param {string | null | undefined} [separator='']
 *   Separator to use.
 * @returns {string}
 *   Result.
 */
// To do next major: remove `separator`.
export function toString(value, separator) {
=======
 * @param {Array<Nodes> | Nodes} value
 *   Node or list of nodes to serialize.
 * @returns {string}
 *   Result.
 */
export function toString(value) {
>>>>>>> 08f40ceb (Initial)
  let index = -1

  if (!value || (!Array.isArray(value) && !value.type)) {
    throw new Error('Expected node, not `' + value + '`')
  }

<<<<<<< HEAD
  // @ts-expect-error Looks like a literal.
  if (typeof value.value === 'string') return value.value

  /** @type {Array<Content|Root>} */
  // @ts-expect-error Looks like a list of nodes or parent.
  const children = (Array.isArray(value) ? value : value.children) || []

  // Shortcut: This is pretty common, and a small performance win.
  if (children.length === 1 && 'value' in children[0]) {
    return children[0].value
  }
=======
  if ('value' in value) return value.value

  const children = (Array.isArray(value) ? value : value.children) || emptyNodes
>>>>>>> 08f40ceb (Initial)

  /** @type {Array<string>} */
  const values = []

  while (++index < children.length) {
<<<<<<< HEAD
    values[index] = toString(children[index], separator)
  }

  return values.join(separator || '')
=======
    values[index] = toString(children[index])
  }

  return values.join('')
>>>>>>> 08f40ceb (Initial)
}
