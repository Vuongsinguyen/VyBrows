/**
<<<<<<< HEAD
 * @typedef {import('vfile').VFile} VFile
 * @typedef {import('vfile').Value} Value
 */

/**
 * @typedef Point
 *   unist point, where `line` and `column` can be `undefined`.
 * @property {number | undefined} line
 *   Line.
 * @property {number | undefined} column
 *   Column.
 * @property {number | undefined} [offset]
 *   Offset.
 *
 * @typedef PointLike
 *   unist point, allowed as input.
 * @property {number | null | undefined} [line]
 *   Line.
 * @property {number | null | undefined} [column]
 *   Column.
 * @property {number | null | undefined} [offset]
 *   Offset.
 *
 * @callback ToPoint
 *   Get a line/column-based `point` from `offset`.
 * @param {number | null | undefined} [offset]
 *   Something that should be an `offset.
 * @returns {Point}
 *   Point, line/column are undefined for invalid or out of bounds input.
 *
 * @callback ToOffset
 *   Get an offset from a line/column-based `point`.
 * @param {Point | null | undefined} [point]
 *   Something that should be a `point.
 * @returns {number}
 *   Offset or `-1` for invalid or out of bounds input.
 *
 * @typedef Location
 *   Accessors for index.
 * @property {ToPoint} toPoint
 *   Get a line/column-based `point` from `offset`.
 * @property {ToOffset} toOffset
 *   Get an offset from a line/column-based `point`.
 */

/**
 * Index the given document so you can translate between line/column and offset
 * based positional info.
=======
 * @import {VFile, Value} from 'vfile'
 * @import {Location} from 'vfile-location'
 */

/**
 * Create an index of the given document to translate between line/column and
 * offset based positional info.
 *
 * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].
 *
 * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs
>>>>>>> 08f40ceb (Initial)
 *
 * @param {VFile | Value} file
 *   File to index.
 * @returns {Location}
 *   Accessors for index.
 */
export function location(file) {
  const value = String(file)
<<<<<<< HEAD
  /** @type {Array<number>} */
  const indices = []
  const search = /\r?\n|\r/g

  while (search.test(value)) {
    indices.push(search.lastIndex)
  }

  indices.push(value.length + 1)

  return {toPoint, toOffset}

  /** @type {ToPoint} */
  function toPoint(offset) {
    let index = -1

    if (
      typeof offset === 'number' &&
      offset > -1 &&
      offset < indices[indices.length - 1]
    ) {
      while (++index < indices.length) {
        if (indices[index] > offset) {
=======
  /**
   * List, where each index is a line number (0-based), and each value is the
   * byte index *after* where the line ends.
   *
   * @type {Array<number>}
   */
  const indices = []

  return {toOffset, toPoint}

  /** @type {Location['toPoint']} */
  function toPoint(offset) {
    if (typeof offset === 'number' && offset > -1 && offset <= value.length) {
      let index = 0

      while (true) {
        let end = indices[index]

        if (end === undefined) {
          const eol = next(value, indices[index - 1])
          end = eol === -1 ? value.length + 1 : eol + 1
          indices[index] = end
        }

        if (end > offset) {
>>>>>>> 08f40ceb (Initial)
          return {
            line: index + 1,
            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,
            offset
          }
        }
<<<<<<< HEAD
      }
    }

    return {line: undefined, column: undefined, offset: undefined}
  }

  /** @type {ToOffset} */
  function toOffset(point) {
    const line = point && point.line
    const column = point && point.column

    if (
      typeof line === 'number' &&
      typeof column === 'number' &&
      !Number.isNaN(line) &&
      !Number.isNaN(column) &&
      line - 1 in indices
    ) {
      const offset = (indices[line - 2] || 0) + column - 1 || 0

      if (offset > -1 && offset < indices[indices.length - 1]) {
        return offset
      }
    }

    return -1
  }
}
=======

        index++
      }
    }
  }

  /** @type {Location['toOffset']} */
  function toOffset(point) {
    if (
      point &&
      typeof point.line === 'number' &&
      typeof point.column === 'number' &&
      !Number.isNaN(point.line) &&
      !Number.isNaN(point.column)
    ) {
      while (indices.length < point.line) {
        const from = indices[indices.length - 1]
        const eol = next(value, from)
        const end = eol === -1 ? value.length + 1 : eol + 1
        if (from === end) break
        indices.push(end)
      }

      const offset =
        (point.line > 1 ? indices[point.line - 2] : 0) + point.column - 1
      // The given `column` could not exist on this line.
      if (offset < indices[point.line - 1]) return offset
    }
  }
}

/**
 * @param {string} value
 * @param {number} from
 */
function next(value, from) {
  const cr = value.indexOf('\r', from)
  const lf = value.indexOf('\n', from)
  if (lf === -1) return cr
  if (cr === -1 || cr + 1 === lf) return lf
  return cr < lf ? cr : lf
}
>>>>>>> 08f40ceb (Initial)
